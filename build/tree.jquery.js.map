{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"jQuery\"","webpack:///./src/version.ts","webpack:///./src/node.ts","webpack:///./src/dragAndDropHandler.ts","webpack:///./src/util.ts","webpack:///./src/elementsRenderer.ts","webpack:///./src/dataLoader.ts","webpack:///./src/keyHandler.ts","webpack:///./src/simple.widget.ts","webpack:///./src/mouse.widget.ts","webpack:///./src/saveStateHandler.ts","webpack:///./src/scrollHandler.ts","webpack:///./src/selectNodeHandler.ts","webpack:///./src/nodeElement.ts","webpack:///./src/tree.jquery.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;AClFA,wB;;;;;;;;;;;;;;;;;;;;;ACAA;AACe,uDAAO,EAAC;;;;;;ACDhB;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,iBAAiB,sBAAsB;;AAEvC,iBAAiB,sCAAsC;;AAEvD,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,KAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC5jBiC;AACkB;AAC5C,MAAM,qCAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,gBAAM;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,oCAAiB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gBAAM;AACjC;AACA;AACA;AACA,mCAAmC,8BAAW;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,eAAe;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,QAAQ;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA;AACA,6BAA6B,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,eAAe;AAC7C;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,sCAAmB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gBAAM;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAM,oCAAiB,SAAS,sCAAmB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA,mCAAmC,QAAQ,qBAAqB,gBAAM;AACtE;AACA;AACA;AACA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,MAAM,8BAAW;AACjB;AACA;AACA;AACA,wBAAwB,gBAAM;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;AC9cO;AACA;AACA;;;ACFgC;AACxB,MAAM,iCAAgB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,YAAY;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,cAAc;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,MAAM;AACtD,gDAAgD,aAAa;AAC7D,gDAAgD,aAAa;AAC7D;AACA;AACA;AACA,sDAAsD,SAAS;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACrMe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,4CAA4C,4FAA4F;AACxI;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACrFe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC5FA;AACA,8CAA8C,WAAW;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9FA;AACA;AACA;AAC2C;AAC3C;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,MAAM,wBAAW,SAAS,YAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,4DAA4D,iBAAiB;AAC7E;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe,yEAAW,EAAC;;;ACnKI;AAChB,MAAM,iCAAgB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,KAAK;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AClNe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACzMe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACpGkC;AAC3B,MAAM,uBAAW;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yBAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;AACO,MAAM,yBAAa,SAAS,uBAAW;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,QAAQ;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA,MAAM,yBAAa;AACnB;AACA;AACA;AACA;AACA;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA,8BAA8B,QAAQ;AACtC;AACA;AACA,8BAA8B,QAAQ;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACpLoC;AACH;AACyB;AACR;AACZ;AACA;AACG;AACS;AACN;AACQ;AACT;AACA;AACP;AACuB;AAC3D;AACA;AACO,MAAM,wBAAY,SAAS,YAAW;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,yBAAyB,gBAAM;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,yBAAyB,EAAE;AAClF,sDAAsD,yBAAyB,EAAE;;AAEjF;AACA;AACA;AACA,0CAA0C,yBAAyB,EAAE;AACrE,2CAA2C,yBAAyB,EAAE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yBAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,WAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gBAAM;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA,sBAAsB,yBAAY;AAClC;AACA;AACA;AACA;AACA;AACA,sCAAsC,yBAAa;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yBAAa;AACpC;AACA;AACA,uBAAuB,uBAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,gBAAM;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iCAAgB;AAC5C,8BAA8B,UAAU;AACxC,oCAAoC,iCAAgB;AACpD,qCAAqC,iBAAiB;AACtD,8BAA8B,qCAAkB;AAChD,iCAAiC,aAAa;AAC9C,8BAA8B,UAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,IAAI,GAAG;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAM;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,4DAA4D,sCAAsC;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,kBAAkB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,wBAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,eAAe,IAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,UAAU,wBAAY","file":"tree.jquery.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","module.exports = jQuery;","const version = \"1.5.0\";\nexport default version;\n","export var Position;\n(function (Position) {\n    Position[Position[\"Before\"] = 1] = \"Before\";\n    Position[Position[\"After\"] = 2] = \"After\";\n    Position[Position[\"Inside\"] = 3] = \"Inside\";\n    Position[Position[\"None\"] = 4] = \"None\";\n})(Position || (Position = {}));\nconst positionNames = {\n    before: Position.Before,\n    after: Position.After,\n    inside: Position.Inside,\n    none: Position.None,\n};\nexport const getPositionName = (position) => {\n    for (const name in positionNames) {\n        if (Object.prototype.hasOwnProperty.call(positionNames, name)) {\n            if (positionNames[name] === position) {\n                return name;\n            }\n        }\n    }\n    return \"\";\n};\nexport const getPosition = (name) => positionNames[name];\nexport class Node {\n    constructor(o = null, isRoot = false, nodeClass = Node) {\n        this.name = \"\";\n        this.isEmptyFolder = false;\n        this.load_on_demand = false;\n        this.setData(o);\n        this.children = [];\n        this.parent = null;\n        if (isRoot) {\n            this.idMapping = {};\n            this.tree = this;\n            this.nodeClass = nodeClass;\n        }\n    }\n    /*\n    Set the data of this node.\n\n    setData(string): set the name of the node\n    setdata(object): set attributes of the node\n\n    Examples:\n        setdata('node1')\n\n        setData({ name: 'node1', id: 1});\n\n        setData({ name: 'node2', id: 2, color: 'green'});\n\n    * This is an internal function; it is not in the docs\n    * Does not remove existing node values\n    */\n    setData(o) {\n        if (!o) {\n            return;\n        }\n        else if (typeof o === \"string\") {\n            this.name = o;\n        }\n        else if (typeof o === \"object\") {\n            for (const key in o) {\n                if (Object.prototype.hasOwnProperty.call(o, key)) {\n                    const value = o[key];\n                    if (key === \"label\" || key === \"name\") {\n                        // You can use the 'label' key instead of 'name'; this is a legacy feature\n                        if (typeof value === \"string\") {\n                            this.name = value;\n                        }\n                    }\n                    else if (key !== \"children\" && key !== \"parent\") {\n                        // You can't update the children or the parent using this function\n                        this[key] = value;\n                    }\n                }\n            }\n        }\n    }\n    /*\n    Create tree from data.\n\n    Structure of data is:\n    [\n        {\n            name: 'node1',\n            children: [\n                { name: 'child1' },\n                { name: 'child2' }\n            ]\n        },\n        {\n            name: 'node2'\n        }\n    ]\n    */\n    loadFromData(data) {\n        this.removeChildren();\n        for (const o of data) {\n            const node = this.createNode(o);\n            this.addChild(node);\n            if (typeof o === \"object\" &&\n                o[\"children\"] &&\n                o[\"children\"] instanceof Array) {\n                if (o[\"children\"].length === 0) {\n                    node.isEmptyFolder = true;\n                }\n                else {\n                    node.loadFromData(o[\"children\"]);\n                }\n            }\n        }\n        return this;\n    }\n    /*\n    Add child.\n\n    tree.addChild(\n        new Node('child1')\n    );\n    */\n    addChild(node) {\n        this.children.push(node);\n        node.setParent(this);\n    }\n    /*\n    Add child at position. Index starts at 0.\n\n    tree.addChildAtPosition(\n        new Node('abc'),\n        1\n    );\n    */\n    addChildAtPosition(node, index) {\n        this.children.splice(index, 0, node);\n        node.setParent(this);\n    }\n    /*\n    Remove child. This also removes the children of the node.\n\n    tree.removeChild(tree.children[0]);\n    */\n    removeChild(node) {\n        // remove children from the index\n        node.removeChildren();\n        this.doRemoveChild(node);\n    }\n    /*\n    Get child index.\n\n    var index = getChildIndex(node);\n    */\n    getChildIndex(node) {\n        return this.children.indexOf(node);\n    }\n    /*\n    Does the tree have children?\n\n    if (tree.hasChildren()) {\n        //\n    }\n    */\n    hasChildren() {\n        return this.children.length !== 0;\n    }\n    isFolder() {\n        return this.hasChildren() || this.load_on_demand;\n    }\n    /*\n    Iterate over all the nodes in the tree.\n\n    Calls callback with (node, level).\n\n    The callback must return true to continue the iteration on current node.\n\n    tree.iterate(\n        function(node, level) {\n           console.log(node.name);\n\n           // stop iteration after level 2\n           return (level <= 2);\n        }\n    );\n\n    */\n    iterate(callback) {\n        const _iterate = (node, level) => {\n            if (node.children) {\n                for (const child of node.children) {\n                    const result = callback(child, level);\n                    if (result && child.hasChildren()) {\n                        _iterate(child, level + 1);\n                    }\n                }\n            }\n        };\n        _iterate(this, 0);\n    }\n    /*\n    Move node relative to another node.\n\n    Argument position: Position.BEFORE, Position.AFTER or Position.Inside\n\n    // move node1 after node2\n    tree.moveNode(node1, node2, Position.AFTER);\n    */\n    moveNode(movedNode, targetNode, position) {\n        if (!movedNode.parent || movedNode.isParentOf(targetNode)) {\n            // - Node is parent of target node\n            // - Or, parent is empty\n            return false;\n        }\n        else {\n            movedNode.parent.doRemoveChild(movedNode);\n            switch (position) {\n                case Position.After: {\n                    if (targetNode.parent) {\n                        targetNode.parent.addChildAtPosition(movedNode, targetNode.parent.getChildIndex(targetNode) + 1);\n                        return true;\n                    }\n                    return false;\n                }\n                case Position.Before: {\n                    if (targetNode.parent) {\n                        targetNode.parent.addChildAtPosition(movedNode, targetNode.parent.getChildIndex(targetNode));\n                        return true;\n                    }\n                    return false;\n                }\n                case Position.Inside: {\n                    // move inside as first child\n                    targetNode.addChildAtPosition(movedNode, 0);\n                    return true;\n                }\n                default:\n                    return false;\n            }\n        }\n    }\n    /*\n    Get the tree as data.\n    */\n    getData(includeParent = false) {\n        const getDataFromNodes = (nodes) => {\n            return nodes.map((node) => {\n                const tmpNode = {};\n                for (const k in node) {\n                    if ([\n                        \"parent\",\n                        \"children\",\n                        \"element\",\n                        \"idMapping\",\n                        \"load_on_demand\",\n                        \"nodeClass\",\n                        \"tree\",\n                        \"isEmptyFolder\",\n                    ].indexOf(k) === -1 &&\n                        Object.prototype.hasOwnProperty.call(node, k)) {\n                        const v = node[k];\n                        tmpNode[k] = v;\n                    }\n                }\n                if (node.hasChildren()) {\n                    tmpNode[\"children\"] = getDataFromNodes(node.children);\n                }\n                return tmpNode;\n            });\n        };\n        if (includeParent) {\n            return getDataFromNodes([this]);\n        }\n        else {\n            return getDataFromNodes(this.children);\n        }\n    }\n    getNodeByName(name) {\n        return this.getNodeByCallback((node) => node.name === name);\n    }\n    getNodeByNameMustExist(name) {\n        const node = this.getNodeByCallback((n) => n.name === name);\n        if (!node) {\n            throw `Node with name ${name} not found`;\n        }\n        return node;\n    }\n    getNodeByCallback(callback) {\n        let result = null;\n        this.iterate((node) => {\n            if (result) {\n                return false;\n            }\n            else if (callback(node)) {\n                result = node;\n                return false;\n            }\n            else {\n                return true;\n            }\n        });\n        return result;\n    }\n    addAfter(nodeInfo) {\n        if (!this.parent) {\n            return null;\n        }\n        else {\n            const node = this.createNode(nodeInfo);\n            const childIndex = this.parent.getChildIndex(this);\n            this.parent.addChildAtPosition(node, childIndex + 1);\n            if (typeof nodeInfo === \"object\" &&\n                nodeInfo[\"children\"] &&\n                nodeInfo[\"children\"] instanceof Array &&\n                nodeInfo[\"children\"].length) {\n                node.loadFromData(nodeInfo[\"children\"]);\n            }\n            return node;\n        }\n    }\n    addBefore(nodeInfo) {\n        if (!this.parent) {\n            return null;\n        }\n        else {\n            const node = this.createNode(nodeInfo);\n            const childIndex = this.parent.getChildIndex(this);\n            this.parent.addChildAtPosition(node, childIndex);\n            if (typeof nodeInfo === \"object\" &&\n                nodeInfo[\"children\"] &&\n                nodeInfo[\"children\"] instanceof Array &&\n                nodeInfo[\"children\"].length) {\n                node.loadFromData(nodeInfo[\"children\"]);\n            }\n            return node;\n        }\n    }\n    addParent(nodeInfo) {\n        if (!this.parent) {\n            return null;\n        }\n        else {\n            const newParent = this.createNode(nodeInfo);\n            if (this.tree) {\n                newParent.setParent(this.tree);\n            }\n            const originalParent = this.parent;\n            for (const child of originalParent.children) {\n                newParent.addChild(child);\n            }\n            originalParent.children = [];\n            originalParent.addChild(newParent);\n            return newParent;\n        }\n    }\n    remove() {\n        if (this.parent) {\n            this.parent.removeChild(this);\n            this.parent = null;\n        }\n    }\n    append(nodeInfo) {\n        const node = this.createNode(nodeInfo);\n        this.addChild(node);\n        if (typeof nodeInfo === \"object\" &&\n            nodeInfo[\"children\"] &&\n            nodeInfo[\"children\"] instanceof Array &&\n            nodeInfo[\"children\"].length) {\n            node.loadFromData(nodeInfo[\"children\"]);\n        }\n        return node;\n    }\n    prepend(nodeInfo) {\n        const node = this.createNode(nodeInfo);\n        this.addChildAtPosition(node, 0);\n        if (typeof nodeInfo === \"object\" &&\n            nodeInfo[\"children\"] &&\n            nodeInfo[\"children\"] instanceof Array &&\n            nodeInfo[\"children\"].length) {\n            node.loadFromData(nodeInfo[\"children\"]);\n        }\n        return node;\n    }\n    isParentOf(node) {\n        let parent = node.parent;\n        while (parent) {\n            if (parent === this) {\n                return true;\n            }\n            parent = parent.parent;\n        }\n        return false;\n    }\n    getLevel() {\n        let level = 0;\n        let node = this; // eslint-disable-line @typescript-eslint/no-this-alias\n        while (node.parent) {\n            level += 1;\n            node = node.parent;\n        }\n        return level;\n    }\n    getNodeById(nodeId) {\n        return this.idMapping[nodeId] || null;\n    }\n    addNodeToIndex(node) {\n        if (node.id != null) {\n            this.idMapping[node.id] = node;\n        }\n    }\n    removeNodeFromIndex(node) {\n        if (node.id != null) {\n            delete this.idMapping[node.id];\n        }\n    }\n    removeChildren() {\n        this.iterate((child) => {\n            var _a;\n            (_a = this.tree) === null || _a === void 0 ? void 0 : _a.removeNodeFromIndex(child);\n            return true;\n        });\n        this.children = [];\n    }\n    getPreviousSibling() {\n        if (!this.parent) {\n            return null;\n        }\n        else {\n            const previousIndex = this.parent.getChildIndex(this) - 1;\n            if (previousIndex >= 0) {\n                return this.parent.children[previousIndex];\n            }\n            else {\n                return null;\n            }\n        }\n    }\n    getNextSibling() {\n        if (!this.parent) {\n            return null;\n        }\n        else {\n            const nextIndex = this.parent.getChildIndex(this) + 1;\n            if (nextIndex < this.parent.children.length) {\n                return this.parent.children[nextIndex];\n            }\n            else {\n                return null;\n            }\n        }\n    }\n    getNodesByProperty(key, value) {\n        return this.filter((node) => node[key] === value);\n    }\n    filter(f) {\n        const result = [];\n        this.iterate((node) => {\n            if (f(node)) {\n                result.push(node);\n            }\n            return true;\n        });\n        return result;\n    }\n    getNextNode(includeChildren = true) {\n        if (includeChildren && this.hasChildren() && this.is_open) {\n            // First child\n            return this.children[0];\n        }\n        else {\n            if (!this.parent) {\n                return null;\n            }\n            else {\n                const nextSibling = this.getNextSibling();\n                if (nextSibling) {\n                    // Next sibling\n                    return nextSibling;\n                }\n                else {\n                    // Next node of parent\n                    return this.parent.getNextNode(false);\n                }\n            }\n        }\n    }\n    getPreviousNode() {\n        if (!this.parent) {\n            return null;\n        }\n        else {\n            const previousSibling = this.getPreviousSibling();\n            if (previousSibling) {\n                if (!previousSibling.hasChildren() ||\n                    !previousSibling.is_open) {\n                    // Previous sibling\n                    return previousSibling;\n                }\n                else {\n                    // Last child of previous sibling\n                    return previousSibling.getLastChild();\n                }\n            }\n            else {\n                return this.getParent();\n            }\n        }\n    }\n    getParent() {\n        // Return parent except if it is the root node\n        if (!this.parent) {\n            return null;\n        }\n        else if (!this.parent.parent) {\n            // Root node -> null\n            return null;\n        }\n        else {\n            return this.parent;\n        }\n    }\n    getLastChild() {\n        if (!this.hasChildren()) {\n            return null;\n        }\n        else {\n            const lastChild = this.children[this.children.length - 1];\n            if (!(lastChild.hasChildren() && lastChild.is_open)) {\n                return lastChild;\n            }\n            else {\n                return lastChild.getLastChild();\n            }\n        }\n    }\n    // Init Node from data without making it the root of the tree\n    initFromData(data) {\n        const addNode = (nodeData) => {\n            this.setData(nodeData);\n            if (typeof nodeData === \"object\" &&\n                nodeData[\"children\"] &&\n                nodeData[\"children\"] instanceof Array &&\n                nodeData[\"children\"].length) {\n                addChildren(nodeData[\"children\"]);\n            }\n        };\n        const addChildren = (childrenData) => {\n            for (const child of childrenData) {\n                const node = this.createNode();\n                node.initFromData(child);\n                this.addChild(node);\n            }\n        };\n        addNode(data);\n    }\n    setParent(parent) {\n        var _a;\n        this.parent = parent;\n        this.tree = parent.tree;\n        (_a = this.tree) === null || _a === void 0 ? void 0 : _a.addNodeToIndex(this);\n    }\n    doRemoveChild(node) {\n        var _a;\n        this.children.splice(this.getChildIndex(node), 1);\n        (_a = this.tree) === null || _a === void 0 ? void 0 : _a.removeNodeFromIndex(node);\n    }\n    getNodeClass() {\n        var _a;\n        return this.nodeClass || ((_a = this === null || this === void 0 ? void 0 : this.tree) === null || _a === void 0 ? void 0 : _a.nodeClass) || Node;\n    }\n    createNode(nodeData) {\n        const nodeClass = this.getNodeClass();\n        return new nodeClass(nodeData);\n    }\n}\n","import * as jQuery from \"jquery\";\nimport { getPositionName, Position } from \"./node\";\nexport class DragAndDropHandler {\n    constructor(treeWidget) {\n        this.treeWidget = treeWidget;\n        this.hoveredArea = null;\n        this.hitAreas = [];\n        this.isDragging = false;\n        this.currentItem = null;\n        this.positionInfo = null;\n    }\n    mouseCapture(positionInfo) {\n        const $element = jQuery(positionInfo.target);\n        if (!this.mustCaptureElement($element)) {\n            return null;\n        }\n        if (this.treeWidget.options.onIsMoveHandle &&\n            !this.treeWidget.options.onIsMoveHandle($element)) {\n            return null;\n        }\n        let nodeElement = this.treeWidget._getNodeElement($element);\n        if (nodeElement && this.treeWidget.options.onCanMove) {\n            if (!this.treeWidget.options.onCanMove(nodeElement.node)) {\n                nodeElement = null;\n            }\n        }\n        this.currentItem = nodeElement;\n        return this.currentItem != null;\n    }\n    generateHitAreas() {\n        if (!this.currentItem) {\n            this.hitAreas = [];\n        }\n        else {\n            const hitAreasGenerator = new HitAreasGenerator(this.treeWidget.tree, this.currentItem.node, this.getTreeDimensions().bottom);\n            this.hitAreas = hitAreasGenerator.generate();\n        }\n    }\n    mouseStart(positionInfo) {\n        var _a;\n        if (!this.currentItem ||\n            positionInfo.pageX === undefined ||\n            positionInfo.pageY === undefined) {\n            return false;\n        }\n        else {\n            this.refresh();\n            const offset = jQuery(positionInfo.target).offset();\n            const left = offset ? offset.left : 0;\n            const top = offset ? offset.top : 0;\n            const node = this.currentItem.node;\n            this.dragElement = new DragElement(node.name, positionInfo.pageX - left, positionInfo.pageY - top, this.treeWidget.element, (_a = this.treeWidget.options.autoEscape) !== null && _a !== void 0 ? _a : true);\n            this.isDragging = true;\n            this.positionInfo = positionInfo;\n            this.currentItem.$element.addClass(\"jqtree-moving\");\n            return true;\n        }\n    }\n    mouseDrag(positionInfo) {\n        if (!this.currentItem ||\n            !this.dragElement ||\n            positionInfo.pageX === undefined ||\n            positionInfo.pageY === undefined) {\n            return false;\n        }\n        else {\n            this.dragElement.move(positionInfo.pageX, positionInfo.pageY);\n            this.positionInfo = positionInfo;\n            const area = this.findHoveredArea(positionInfo.pageX, positionInfo.pageY);\n            const canMoveTo = this.canMoveToArea(area);\n            if (canMoveTo && area) {\n                if (!area.node.isFolder()) {\n                    this.stopOpenFolderTimer();\n                }\n                if (this.hoveredArea !== area) {\n                    this.hoveredArea = area;\n                    // If this is a closed folder, start timer to open it\n                    if (this.mustOpenFolderTimer(area)) {\n                        this.startOpenFolderTimer(area.node);\n                    }\n                    else {\n                        this.stopOpenFolderTimer();\n                    }\n                    this.updateDropHint();\n                }\n            }\n            else {\n                this.removeHover();\n                this.removeDropHint();\n                this.stopOpenFolderTimer();\n            }\n            if (!area) {\n                if (this.treeWidget.options.onDragMove) {\n                    this.treeWidget.options.onDragMove(this.currentItem.node, positionInfo.originalEvent);\n                }\n            }\n            return true;\n        }\n    }\n    mouseStop(positionInfo) {\n        this.moveItem(positionInfo);\n        this.clear();\n        this.removeHover();\n        this.removeDropHint();\n        this.removeHitAreas();\n        const currentItem = this.currentItem;\n        if (this.currentItem) {\n            this.currentItem.$element.removeClass(\"jqtree-moving\");\n            this.currentItem = null;\n        }\n        this.isDragging = false;\n        this.positionInfo = null;\n        if (!this.hoveredArea && currentItem) {\n            if (this.treeWidget.options.onDragStop) {\n                this.treeWidget.options.onDragStop(currentItem.node, positionInfo.originalEvent);\n            }\n        }\n        return false;\n    }\n    refresh() {\n        this.removeHitAreas();\n        if (this.currentItem) {\n            this.generateHitAreas();\n            this.currentItem = this.treeWidget._getNodeElementForNode(this.currentItem.node);\n            if (this.isDragging) {\n                this.currentItem.$element.addClass(\"jqtree-moving\");\n            }\n        }\n    }\n    mustCaptureElement($element) {\n        return !$element.is(\"input,select,textarea\");\n    }\n    canMoveToArea(area) {\n        if (!area || !this.currentItem) {\n            return false;\n        }\n        else if (this.treeWidget.options.onCanMoveTo) {\n            const positionName = getPositionName(area.position);\n            return this.treeWidget.options.onCanMoveTo(this.currentItem.node, area.node, positionName);\n        }\n        else {\n            return true;\n        }\n    }\n    removeHitAreas() {\n        this.hitAreas = [];\n    }\n    clear() {\n        if (this.dragElement) {\n            this.dragElement.remove();\n            this.dragElement = null;\n        }\n    }\n    removeDropHint() {\n        if (this.previousGhost) {\n            this.previousGhost.remove();\n        }\n    }\n    removeHover() {\n        this.hoveredArea = null;\n    }\n    findHoveredArea(x, y) {\n        const dimensions = this.getTreeDimensions();\n        if (x < dimensions.left ||\n            y < dimensions.top ||\n            x > dimensions.right ||\n            y > dimensions.bottom) {\n            return null;\n        }\n        let low = 0;\n        let high = this.hitAreas.length;\n        while (low < high) {\n            const mid = (low + high) >> 1;\n            const area = this.hitAreas[mid];\n            if (y < area.top) {\n                high = mid;\n            }\n            else if (y > area.bottom) {\n                low = mid + 1;\n            }\n            else {\n                return area;\n            }\n        }\n        return null;\n    }\n    mustOpenFolderTimer(area) {\n        const node = area.node;\n        return (node.isFolder() &&\n            !node.is_open &&\n            area.position === Position.Inside);\n    }\n    updateDropHint() {\n        if (!this.hoveredArea) {\n            return;\n        }\n        // remove previous drop hint\n        this.removeDropHint();\n        // add new drop hint\n        const nodeElement = this.treeWidget._getNodeElementForNode(this.hoveredArea.node);\n        this.previousGhost = nodeElement.addDropHint(this.hoveredArea.position);\n    }\n    startOpenFolderTimer(folder) {\n        const openFolder = () => {\n            this.treeWidget._openNode(folder, this.treeWidget.options.slide, () => {\n                this.refresh();\n                this.updateDropHint();\n            });\n        };\n        this.stopOpenFolderTimer();\n        this.openFolderTimer = window.setTimeout(openFolder, this.treeWidget.options.openFolderDelay);\n    }\n    stopOpenFolderTimer() {\n        if (this.openFolderTimer) {\n            clearTimeout(this.openFolderTimer);\n            this.openFolderTimer = null;\n        }\n    }\n    moveItem(positionInfo) {\n        if (this.currentItem &&\n            this.hoveredArea &&\n            this.hoveredArea.position !== Position.None &&\n            this.canMoveToArea(this.hoveredArea)) {\n            const movedNode = this.currentItem.node;\n            const targetNode = this.hoveredArea.node;\n            const position = this.hoveredArea.position;\n            const previousParent = movedNode.parent;\n            if (position === Position.Inside) {\n                this.hoveredArea.node.is_open = true;\n            }\n            const doMove = () => {\n                this.treeWidget.tree.moveNode(movedNode, targetNode, position);\n                this.treeWidget.element.empty();\n                this.treeWidget._refreshElements(null);\n            };\n            const event = this.treeWidget._triggerEvent(\"tree.move\", {\n                move_info: {\n                    moved_node: movedNode,\n                    target_node: targetNode,\n                    position: getPositionName(position),\n                    previous_parent: previousParent,\n                    do_move: doMove,\n                    original_event: positionInfo.originalEvent,\n                },\n            });\n            if (!event.isDefaultPrevented()) {\n                doMove();\n            }\n        }\n    }\n    getTreeDimensions() {\n        // Return the dimensions of the tree. Add a margin to the bottom to allow\n        // to drag-and-drop after the last element.\n        const offset = this.treeWidget.element.offset();\n        if (!offset) {\n            return { left: 0, top: 0, right: 0, bottom: 0 };\n        }\n        else {\n            const el = this.treeWidget.element;\n            const width = el.width() || 0;\n            const height = el.height() || 0;\n            const left = offset.left + this.treeWidget._getScrollLeft();\n            return {\n                left,\n                top: offset.top,\n                right: left + width,\n                bottom: offset.top + height + 16,\n            };\n        }\n    }\n}\nclass VisibleNodeIterator {\n    constructor(tree) {\n        this.tree = tree;\n    }\n    iterate() {\n        let isFirstNode = true;\n        const _iterateNode = (node, nextNode) => {\n            let mustIterateInside = (node.is_open || !node.element) && node.hasChildren();\n            let $element = null;\n            if (node.element) {\n                $element = jQuery(node.element);\n                if (!$element.is(\":visible\")) {\n                    return;\n                }\n                if (isFirstNode) {\n                    this.handleFirstNode(node);\n                    isFirstNode = false;\n                }\n                if (!node.hasChildren()) {\n                    this.handleNode(node, nextNode, $element);\n                }\n                else if (node.is_open) {\n                    if (!this.handleOpenFolder(node, $element)) {\n                        mustIterateInside = false;\n                    }\n                }\n                else {\n                    this.handleClosedFolder(node, nextNode, $element);\n                }\n            }\n            if (mustIterateInside) {\n                const childrenLength = node.children.length;\n                node.children.forEach((_, i) => {\n                    if (i === childrenLength - 1) {\n                        _iterateNode(node.children[i], null);\n                    }\n                    else {\n                        _iterateNode(node.children[i], node.children[i + 1]);\n                    }\n                });\n                if (node.is_open && $element) {\n                    this.handleAfterOpenFolder(node, nextNode);\n                }\n            }\n        };\n        _iterateNode(this.tree, null);\n    }\n}\nexport class HitAreasGenerator extends VisibleNodeIterator {\n    constructor(tree, currentNode, treeBottom) {\n        super(tree);\n        this.currentNode = currentNode;\n        this.treeBottom = treeBottom;\n    }\n    generate() {\n        this.positions = [];\n        this.lastTop = 0;\n        this.iterate();\n        return this.generateHitAreas(this.positions);\n    }\n    generateHitAreas(positions) {\n        let previousTop = -1;\n        let group = [];\n        const hitAreas = [];\n        for (const position of positions) {\n            if (position.top !== previousTop && group.length) {\n                if (group.length) {\n                    this.generateHitAreasForGroup(hitAreas, group, previousTop, position.top);\n                }\n                previousTop = position.top;\n                group = [];\n            }\n            group.push(position);\n        }\n        this.generateHitAreasForGroup(hitAreas, group, previousTop, this.treeBottom);\n        return hitAreas;\n    }\n    handleOpenFolder(node, $element) {\n        if (node === this.currentNode) {\n            // Cannot move inside current item\n            // Stop iterating\n            return false;\n        }\n        // Cannot move before current item\n        if (node.children[0] !== this.currentNode) {\n            this.addPosition(node, Position.Inside, this.getTop($element));\n        }\n        // Continue iterating\n        return true;\n    }\n    handleClosedFolder(node, nextNode, $element) {\n        const top = this.getTop($element);\n        if (node === this.currentNode) {\n            // Cannot move after current item\n            this.addPosition(node, Position.None, top);\n        }\n        else {\n            this.addPosition(node, Position.Inside, top);\n            // Cannot move before current item\n            if (nextNode !== this.currentNode) {\n                this.addPosition(node, Position.After, top);\n            }\n        }\n    }\n    handleFirstNode(node) {\n        if (node !== this.currentNode) {\n            this.addPosition(node, Position.Before, this.getTop(jQuery(node.element)));\n        }\n    }\n    handleAfterOpenFolder(node, nextNode) {\n        if (node === this.currentNode || nextNode === this.currentNode) {\n            // Cannot move before or after current item\n            this.addPosition(node, Position.None, this.lastTop);\n        }\n        else {\n            this.addPosition(node, Position.After, this.lastTop);\n        }\n    }\n    handleNode(node, nextNode, $element) {\n        const top = this.getTop($element);\n        if (node === this.currentNode) {\n            // Cannot move inside current item\n            this.addPosition(node, Position.None, top);\n        }\n        else {\n            this.addPosition(node, Position.Inside, top);\n        }\n        if (nextNode === this.currentNode || node === this.currentNode) {\n            // Cannot move before or after current item\n            this.addPosition(node, Position.None, top);\n        }\n        else {\n            this.addPosition(node, Position.After, top);\n        }\n    }\n    getTop($element) {\n        const offset = $element.offset();\n        return offset ? offset.top : 0;\n    }\n    addPosition(node, position, top) {\n        const area = {\n            top,\n            bottom: 0,\n            node,\n            position,\n        };\n        this.positions.push(area);\n        this.lastTop = top;\n    }\n    generateHitAreasForGroup(hitAreas, positionsInGroup, top, bottom) {\n        // limit positions in group\n        const positionCount = Math.min(positionsInGroup.length, 4);\n        const areaHeight = Math.round((bottom - top) / positionCount);\n        let areaTop = top;\n        let i = 0;\n        while (i < positionCount) {\n            const position = positionsInGroup[i];\n            hitAreas.push({\n                top: areaTop,\n                bottom: areaTop + areaHeight,\n                node: position.node,\n                position: position.position,\n            });\n            areaTop += areaHeight;\n            i += 1;\n        }\n    }\n}\nclass DragElement {\n    constructor(nodeName, offsetX, offsetY, $tree, autoEscape) {\n        this.offsetX = offsetX;\n        this.offsetY = offsetY;\n        this.$element = jQuery(\"<span>\").addClass(\"jqtree-title jqtree-dragging\");\n        if (autoEscape) {\n            this.$element.text(nodeName);\n        }\n        else {\n            this.$element.html(nodeName);\n        }\n        this.$element.css(\"position\", \"absolute\");\n        $tree.append(this.$element);\n    }\n    move(pageX, pageY) {\n        this.$element.offset({\n            left: pageX - this.offsetX,\n            top: pageY - this.offsetY,\n        });\n    }\n    remove() {\n        this.$element.remove();\n    }\n}\n","export const isInt = (n) => typeof n === \"number\" && n % 1 === 0;\nexport const isFunction = (v) => typeof v === \"function\";\nexport const getBoolString = (value) => value ? \"true\" : \"false\";\n","import { getBoolString } from \"./util\";\nexport default class ElementsRenderer {\n    constructor(treeWidget) {\n        this.treeWidget = treeWidget;\n        this.openedIconElement = this.createButtonElement(treeWidget.options.openedIcon || \"+\");\n        this.closedIconElement = this.createButtonElement(treeWidget.options.closedIcon || \"-\");\n    }\n    render(fromNode) {\n        if (fromNode && fromNode.parent) {\n            this.renderFromNode(fromNode);\n        }\n        else {\n            this.renderFromRoot();\n        }\n    }\n    renderFromRoot() {\n        const $element = this.treeWidget.element;\n        $element.empty();\n        this.createDomElements($element[0], this.treeWidget.tree.children, true, 1);\n    }\n    renderFromNode(node) {\n        // remember current li\n        const $previousLi = jQuery(node.element);\n        // create element\n        const li = this.createLi(node, node.getLevel());\n        this.attachNodeData(node, li);\n        // add element to dom\n        $previousLi.after(li);\n        // remove previous li\n        $previousLi.remove();\n        // create children\n        if (node.children) {\n            this.createDomElements(li, node.children, false, node.getLevel() + 1);\n        }\n    }\n    createDomElements(element, children, isRootNode, level) {\n        const ul = this.createUl(isRootNode);\n        element.appendChild(ul);\n        for (const child of children) {\n            const li = this.createLi(child, level);\n            ul.appendChild(li);\n            this.attachNodeData(child, li);\n            if (child.hasChildren()) {\n                this.createDomElements(li, child.children, false, level + 1);\n            }\n        }\n    }\n    attachNodeData(node, li) {\n        node.element = li;\n        jQuery(li).data(\"node\", node);\n    }\n    createUl(isRootNode) {\n        let classString;\n        let role;\n        if (!isRootNode) {\n            classString = \"\";\n            role = \"group\";\n        }\n        else {\n            classString = \"jqtree-tree\";\n            role = \"tree\";\n            if (this.treeWidget.options.rtl) {\n                classString += \" jqtree-rtl\";\n            }\n        }\n        if (this.treeWidget.options.dragAndDrop) {\n            classString += \" jqtree-dnd\";\n        }\n        const ul = document.createElement(\"ul\");\n        ul.className = `jqtree_common ${classString}`;\n        ul.setAttribute(\"role\", role);\n        return ul;\n    }\n    createLi(node, level) {\n        const isSelected = Boolean(this.treeWidget.selectNodeHandler.isNodeSelected(node));\n        const mustShowFolder = node.isFolder() ||\n            (node.isEmptyFolder && this.treeWidget.options.showEmptyFolder);\n        const li = mustShowFolder\n            ? this.createFolderLi(node, level, isSelected)\n            : this.createNodeLi(node, level, isSelected);\n        if (this.treeWidget.options.onCreateLi) {\n            this.treeWidget.options.onCreateLi(node, jQuery(li), isSelected);\n        }\n        return li;\n    }\n    createFolderLi(node, level, isSelected) {\n        const buttonClasses = this.getButtonClasses(node);\n        const folderClasses = this.getFolderClasses(node, isSelected);\n        const iconElement = node.is_open\n            ? this.openedIconElement\n            : this.closedIconElement;\n        // li\n        const li = document.createElement(\"li\");\n        li.className = `jqtree_common ${folderClasses}`;\n        li.setAttribute(\"role\", \"presentation\");\n        // div\n        const div = document.createElement(\"div\");\n        div.className = \"jqtree-element jqtree_common\";\n        div.setAttribute(\"role\", \"presentation\");\n        li.appendChild(div);\n        // button link\n        const buttonLink = document.createElement(\"a\");\n        buttonLink.className = buttonClasses;\n        buttonLink.appendChild(iconElement.cloneNode(true));\n        buttonLink.setAttribute(\"role\", \"presentation\");\n        buttonLink.setAttribute(\"aria-hidden\", \"true\");\n        if (this.treeWidget.options.buttonLeft) {\n            div.appendChild(buttonLink);\n        }\n        // title span\n        div.appendChild(this.createTitleSpan(node.name, level, isSelected, node.is_open, true));\n        if (!this.treeWidget.options.buttonLeft) {\n            div.appendChild(buttonLink);\n        }\n        return li;\n    }\n    createNodeLi(node, level, isSelected) {\n        const liClasses = [\"jqtree_common\"];\n        if (isSelected) {\n            liClasses.push(\"jqtree-selected\");\n        }\n        const classString = liClasses.join(\" \");\n        // li\n        const li = document.createElement(\"li\");\n        li.className = classString;\n        li.setAttribute(\"role\", \"presentation\");\n        // div\n        const div = document.createElement(\"div\");\n        div.className = \"jqtree-element jqtree_common\";\n        div.setAttribute(\"role\", \"presentation\");\n        li.appendChild(div);\n        // title span\n        div.appendChild(this.createTitleSpan(node.name, level, isSelected, node.is_open, false));\n        return li;\n    }\n    createTitleSpan(nodeName, level, isSelected, isOpen, isFolder) {\n        const titleSpan = document.createElement(\"span\");\n        let classes = \"jqtree-title jqtree_common\";\n        if (isFolder) {\n            classes += \" jqtree-title-folder\";\n        }\n        titleSpan.className = classes;\n        titleSpan.setAttribute(\"role\", \"treeitem\");\n        titleSpan.setAttribute(\"aria-level\", `${level}`);\n        titleSpan.setAttribute(\"aria-selected\", getBoolString(isSelected));\n        titleSpan.setAttribute(\"aria-expanded\", getBoolString(isOpen));\n        if (isSelected) {\n            const tabIndex = this.treeWidget.options.tabIndex;\n            if (tabIndex !== undefined) {\n                titleSpan.setAttribute(\"tabindex\", `${tabIndex}`);\n            }\n        }\n        if (this.treeWidget.options.autoEscape) {\n            titleSpan.textContent = nodeName;\n        }\n        else {\n            titleSpan.innerHTML = nodeName;\n        }\n        return titleSpan;\n    }\n    getButtonClasses(node) {\n        const classes = [\"jqtree-toggler\", \"jqtree_common\"];\n        if (!node.is_open) {\n            classes.push(\"jqtree-closed\");\n        }\n        if (this.treeWidget.options.buttonLeft) {\n            classes.push(\"jqtree-toggler-left\");\n        }\n        else {\n            classes.push(\"jqtree-toggler-right\");\n        }\n        return classes.join(\" \");\n    }\n    getFolderClasses(node, isSelected) {\n        const classes = [\"jqtree-folder\"];\n        if (!node.is_open) {\n            classes.push(\"jqtree-closed\");\n        }\n        if (isSelected) {\n            classes.push(\"jqtree-selected\");\n        }\n        if (node.is_loading) {\n            classes.push(\"jqtree-loading\");\n        }\n        return classes.join(\" \");\n    }\n    createButtonElement(value) {\n        if (typeof value === \"string\") {\n            // convert value to html\n            const div = document.createElement(\"div\");\n            div.innerHTML = value;\n            return document.createTextNode(div.innerHTML);\n        }\n        else {\n            return jQuery(value)[0];\n        }\n    }\n}\n","export default class DataLoader {\n    constructor(treeWidget) {\n        this.treeWidget = treeWidget;\n    }\n    loadFromUrl(urlInfo, parentNode, onFinished) {\n        if (!urlInfo) {\n            return;\n        }\n        const $el = this.getDomElement(parentNode);\n        this.addLoadingClass($el);\n        this.notifyLoading(true, parentNode, $el);\n        const stopLoading = () => {\n            this.removeLoadingClass($el);\n            this.notifyLoading(false, parentNode, $el);\n        };\n        const handleSuccess = (data) => {\n            stopLoading();\n            this.treeWidget.loadData(this.parseData(data), parentNode);\n            if (onFinished && typeof onFinished === \"function\") {\n                onFinished();\n            }\n        };\n        const handleError = (jqXHR) => {\n            stopLoading();\n            if (this.treeWidget.options.onLoadFailed) {\n                this.treeWidget.options.onLoadFailed(jqXHR);\n            }\n        };\n        this.submitRequest(urlInfo, handleSuccess, handleError);\n    }\n    addLoadingClass($el) {\n        if ($el) {\n            $el.addClass(\"jqtree-loading\");\n        }\n    }\n    removeLoadingClass($el) {\n        if ($el) {\n            $el.removeClass(\"jqtree-loading\");\n        }\n    }\n    getDomElement(parentNode) {\n        if (parentNode) {\n            return jQuery(parentNode.element);\n        }\n        else {\n            return this.treeWidget.element;\n        }\n    }\n    notifyLoading(isLoading, node, $el) {\n        if (this.treeWidget.options.onLoading) {\n            this.treeWidget.options.onLoading(isLoading, node, $el);\n        }\n        this.treeWidget._triggerEvent(\"tree.loading_data\", {\n            isLoading,\n            node,\n            $el,\n        });\n    }\n    submitRequest(urlInfoInput, handleSuccess, handleError) {\n        var _a;\n        const urlInfo = typeof urlInfoInput === \"string\"\n            ? { url: urlInfoInput }\n            : urlInfoInput;\n        const ajaxSettings = Object.assign({ method: \"GET\", cache: false, dataType: \"json\", success: handleSuccess, error: handleError }, urlInfo);\n        ajaxSettings.method = ((_a = ajaxSettings.method) === null || _a === void 0 ? void 0 : _a.toUpperCase()) || \"GET\";\n        void jQuery.ajax(ajaxSettings);\n    }\n    parseData(data) {\n        const { dataFilter } = this.treeWidget.options;\n        const getParsedData = () => {\n            if (typeof data === \"string\") {\n                return JSON.parse(data);\n            }\n            else {\n                return data;\n            }\n        };\n        const parsedData = getParsedData();\n        if (dataFilter) {\n            return dataFilter(parsedData);\n        }\n        else {\n            return parsedData;\n        }\n    }\n}\n","export default class KeyHandler {\n    constructor(treeWidget) {\n        this.handleKeyDown = (e) => {\n            if (!this.canHandleKeyboard()) {\n                return true;\n            }\n            const selectedNode = this.treeWidget.getSelectedNode();\n            if (!selectedNode) {\n                return true;\n            }\n            const key = e.which;\n            switch (key) {\n                case KeyHandler.DOWN:\n                    return this.moveDown(selectedNode);\n                case KeyHandler.UP:\n                    return this.moveUp(selectedNode);\n                case KeyHandler.RIGHT:\n                    return this.moveRight(selectedNode);\n                case KeyHandler.LEFT:\n                    return this.moveLeft(selectedNode);\n                default:\n                    return true;\n            }\n        };\n        this.treeWidget = treeWidget;\n        if (treeWidget.options.keyboardSupport) {\n            jQuery(document).on(\"keydown.jqtree\", this.handleKeyDown);\n        }\n    }\n    deinit() {\n        jQuery(document).off(\"keydown.jqtree\");\n    }\n    moveDown(selectedNode) {\n        return this.selectNode(selectedNode.getNextNode());\n    }\n    moveUp(selectedNode) {\n        return this.selectNode(selectedNode.getPreviousNode());\n    }\n    moveRight(selectedNode) {\n        if (!selectedNode.isFolder()) {\n            return true;\n        }\n        else {\n            // folder node\n            if (selectedNode.is_open) {\n                // Right moves to the first child of an open node\n                return this.selectNode(selectedNode.getNextNode());\n            }\n            else {\n                // Right expands a closed node\n                this.treeWidget.openNode(selectedNode);\n                return false;\n            }\n        }\n    }\n    moveLeft(selectedNode) {\n        if (selectedNode.isFolder() && selectedNode.is_open) {\n            // Left on an open node closes the node\n            this.treeWidget.closeNode(selectedNode);\n            return false;\n        }\n        else {\n            // Left on a closed or end node moves focus to the node's parent\n            return this.selectNode(selectedNode.getParent());\n        }\n    }\n    selectNode(node) {\n        if (!node) {\n            return true;\n        }\n        else {\n            this.treeWidget.selectNode(node);\n            if (!this.treeWidget.scrollHandler.isScrolledIntoView(jQuery(node.element).find(\".jqtree-element\"))) {\n                this.treeWidget.scrollToNode(node);\n            }\n            return false;\n        }\n    }\n    canHandleKeyboard() {\n        return ((this.treeWidget.options.keyboardSupport || false) &&\n            this.isFocusOnTree());\n    }\n    isFocusOnTree() {\n        const activeElement = document.activeElement;\n        return Boolean(activeElement &&\n            activeElement.tagName === \"SPAN\" &&\n            this.treeWidget._containsElement(activeElement));\n    }\n}\nKeyHandler.LEFT = 37;\nKeyHandler.UP = 38;\nKeyHandler.RIGHT = 39;\nKeyHandler.DOWN = 40;\n","const register = (widgetClass, widgetName) => {\n    const getDataKey = () => `simple_widget_${widgetName}`;\n    const getWidgetData = (el, dataKey) => {\n        const widget = jQuery.data(el, dataKey);\n        if (widget && widget instanceof SimpleWidget) {\n            return widget;\n        }\n        else {\n            return null;\n        }\n    };\n    const createWidget = ($el, options) => {\n        const dataKey = getDataKey();\n        for (const el of $el.get()) {\n            const existingWidget = getWidgetData(el, dataKey);\n            if (!existingWidget) {\n                const simpleWidgetClass = widgetClass;\n                const widget = new simpleWidgetClass(el, options);\n                if (!jQuery.data(el, dataKey)) {\n                    jQuery.data(el, dataKey, widget);\n                }\n                // Call init after setting data, so we can call methods\n                widget.init();\n            }\n        }\n        return $el;\n    };\n    const destroyWidget = ($el) => {\n        const dataKey = getDataKey();\n        for (const el of $el.get()) {\n            const widget = getWidgetData(el, dataKey);\n            if (widget) {\n                widget.destroy();\n            }\n            jQuery.removeData(el, dataKey);\n        }\n    };\n    const callFunction = ($el, functionName, args) => {\n        let result = null;\n        for (const el of $el.get()) {\n            const widget = jQuery.data(el, getDataKey());\n            if (widget && widget instanceof SimpleWidget) {\n                const simpleWidget = widget;\n                const widgetFunction = simpleWidget[functionName];\n                if (widgetFunction && typeof widgetFunction === \"function\") {\n                    result = widgetFunction.apply(widget, args);\n                }\n            }\n        }\n        return result;\n    };\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    jQuery.fn[widgetName] = function (argument1, ...args) {\n        if (!argument1) {\n            return createWidget(this, null);\n        }\n        else if (typeof argument1 === \"object\") {\n            const options = argument1;\n            return createWidget(this, options);\n        }\n        else if (typeof argument1 === \"string\" && argument1[0] !== \"_\") {\n            const functionName = argument1;\n            if (functionName === \"destroy\") {\n                return destroyWidget(this);\n            }\n            else if (functionName === \"get_widget_class\") {\n                return widgetClass;\n            }\n            else {\n                return callFunction(this, functionName, args);\n            }\n        }\n    };\n};\nexport default class SimpleWidget {\n    constructor(el, options) {\n        this.$el = jQuery(el);\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        const defaults = this.constructor[\"defaults\"];\n        this.options = Object.assign(Object.assign({}, defaults), options);\n    }\n    static register(widgetClass, widgetName) {\n        register(widgetClass, widgetName);\n    }\n    destroy() {\n        this.deinit();\n    }\n    init() {\n        //\n    }\n    deinit() {\n        //\n    }\n}\nSimpleWidget.defaults = {};\n","/*\nThis widget does the same a the mouse widget in jqueryui.\n*/\nimport SimpleWidget from \"./simple.widget\";\nconst getPositionInfoFromMouseEvent = (e) => ({\n    pageX: e.pageX,\n    pageY: e.pageY,\n    target: e.target,\n    originalEvent: e,\n});\nconst getPositionInfoFromTouch = (touch, e) => ({\n    pageX: touch.pageX,\n    pageY: touch.pageY,\n    target: touch.target,\n    originalEvent: e,\n});\nclass MouseWidget extends SimpleWidget {\n    constructor() {\n        super(...arguments);\n        this.mouseDown = (e) => {\n            // Left mouse button?\n            if (e.button !== 0) {\n                return;\n            }\n            const result = this.handleMouseDown(getPositionInfoFromMouseEvent(e));\n            if (result && e.cancelable) {\n                e.preventDefault();\n            }\n        };\n        this.mouseMove = (e) => {\n            this.handleMouseMove(e, getPositionInfoFromMouseEvent(e));\n        };\n        this.mouseUp = (e) => {\n            this.handleMouseUp(getPositionInfoFromMouseEvent(e));\n        };\n        this.touchStart = (e) => {\n            if (!e) {\n                return;\n            }\n            if (e.touches.length > 1) {\n                return;\n            }\n            const touch = e.changedTouches[0];\n            this.handleMouseDown(getPositionInfoFromTouch(touch, e));\n        };\n        this.touchMove = (e) => {\n            if (!e) {\n                return;\n            }\n            if (e.touches.length > 1) {\n                return;\n            }\n            const touch = e.changedTouches[0];\n            this.handleMouseMove(e, getPositionInfoFromTouch(touch, e));\n        };\n        this.touchEnd = (e) => {\n            if (!e) {\n                return;\n            }\n            if (e.touches.length > 1) {\n                return;\n            }\n            const touch = e.changedTouches[0];\n            this.handleMouseUp(getPositionInfoFromTouch(touch, e));\n        };\n    }\n    setMouseDelay(mouseDelay) {\n        this.mouseDelay = mouseDelay;\n    }\n    init() {\n        const element = this.$el.get(0);\n        element.addEventListener(\"mousedown\", this.mouseDown, {\n            passive: false,\n        });\n        element.addEventListener(\"touchstart\", this.touchStart, {\n            passive: false,\n        });\n        this.isMouseStarted = false;\n        this.mouseDelay = 0;\n        this.mouseDelayTimer = null;\n        this.isMouseDelayMet = false;\n        this.mouseDownInfo = null;\n    }\n    deinit() {\n        const el = this.$el.get(0);\n        el.removeEventListener(\"mousedown\", this.mouseDown);\n        el.removeEventListener(\"touchstart\", this.touchStart);\n        document.removeEventListener(\"mousemove\", this.mouseMove);\n        document.removeEventListener(\"touchmove\", this.touchMove);\n        document.removeEventListener(\"mouseup\", this.mouseUp);\n        document.removeEventListener(\"touchend\", this.touchEnd);\n    }\n    handleMouseDown(positionInfo) {\n        // We may have missed mouseup (out of window)\n        if (this.isMouseStarted) {\n            this.handleMouseUp(positionInfo);\n        }\n        this.mouseDownInfo = positionInfo;\n        if (!this.mouseCapture(positionInfo)) {\n            return false;\n        }\n        this.handleStartMouse();\n        return true;\n    }\n    handleStartMouse() {\n        document.addEventListener(\"mousemove\", this.mouseMove, {\n            passive: false,\n        });\n        document.addEventListener(\"touchmove\", this.touchMove, {\n            passive: false,\n        });\n        document.addEventListener(\"mouseup\", this.mouseUp, { passive: false });\n        document.addEventListener(\"touchend\", this.touchEnd, {\n            passive: false,\n        });\n        if (this.mouseDelay) {\n            this.startMouseDelayTimer();\n        }\n    }\n    startMouseDelayTimer() {\n        if (this.mouseDelayTimer) {\n            clearTimeout(this.mouseDelayTimer);\n        }\n        this.mouseDelayTimer = window.setTimeout(() => {\n            this.isMouseDelayMet = true;\n        }, this.mouseDelay);\n        this.isMouseDelayMet = false;\n    }\n    handleMouseMove(e, positionInfo) {\n        if (this.isMouseStarted) {\n            this.mouseDrag(positionInfo);\n            if (e.cancelable) {\n                e.preventDefault();\n            }\n            return;\n        }\n        if (this.mouseDelay && !this.isMouseDelayMet) {\n            return;\n        }\n        if (this.mouseDownInfo) {\n            this.isMouseStarted = this.mouseStart(this.mouseDownInfo) !== false;\n        }\n        if (this.isMouseStarted) {\n            this.mouseDrag(positionInfo);\n            if (e.cancelable) {\n                e.preventDefault();\n            }\n        }\n        else {\n            this.handleMouseUp(positionInfo);\n        }\n    }\n    handleMouseUp(positionInfo) {\n        document.removeEventListener(\"mousemove\", this.mouseMove);\n        document.removeEventListener(\"touchmove\", this.touchMove);\n        document.removeEventListener(\"mouseup\", this.mouseUp);\n        document.removeEventListener(\"touchend\", this.touchEnd);\n        if (this.isMouseStarted) {\n            this.isMouseStarted = false;\n            this.mouseStop(positionInfo);\n        }\n    }\n}\nexport default MouseWidget;\n","import { isInt } from \"./util\";\nexport default class SaveStateHandler {\n    constructor(treeWidget) {\n        this.treeWidget = treeWidget;\n    }\n    saveState() {\n        const state = JSON.stringify(this.getState());\n        if (this.treeWidget.options.onSetStateFromStorage) {\n            this.treeWidget.options.onSetStateFromStorage(state);\n        }\n        else if (this.supportsLocalStorage()) {\n            localStorage.setItem(this.getKeyName(), state);\n        }\n    }\n    getStateFromStorage() {\n        const jsonData = this.loadFromStorage();\n        if (jsonData) {\n            return this.parseState(jsonData);\n        }\n        else {\n            return null;\n        }\n    }\n    getState() {\n        const getOpenNodeIds = () => {\n            const openNodes = [];\n            this.treeWidget.tree.iterate((node) => {\n                if (node.is_open && node.id && node.hasChildren()) {\n                    openNodes.push(node.id);\n                }\n                return true;\n            });\n            return openNodes;\n        };\n        const getSelectedNodeIds = () => {\n            const selectedNodeIds = [];\n            this.treeWidget.getSelectedNodes().forEach((node) => {\n                if (node.id != null) {\n                    selectedNodeIds.push(node.id);\n                }\n            });\n            return selectedNodeIds;\n        };\n        return {\n            open_nodes: getOpenNodeIds(),\n            selected_node: getSelectedNodeIds(),\n        };\n    }\n    /*\n    Set initial state\n    Don't handle nodes that are loaded on demand\n\n    result: must load on demand\n    */\n    setInitialState(state) {\n        if (!state) {\n            return false;\n        }\n        else {\n            let mustLoadOnDemand = false;\n            if (state.open_nodes) {\n                mustLoadOnDemand = this.openInitialNodes(state.open_nodes);\n            }\n            if (state.selected_node) {\n                this.resetSelection();\n                this.selectInitialNodes(state.selected_node);\n            }\n            return mustLoadOnDemand;\n        }\n    }\n    setInitialStateOnDemand(state, cbFinished) {\n        if (state) {\n            this.doSetInitialStateOnDemand(state.open_nodes, state.selected_node, cbFinished);\n        }\n        else {\n            cbFinished();\n        }\n    }\n    getNodeIdToBeSelected() {\n        const state = this.getStateFromStorage();\n        if (state && state.selected_node) {\n            return state.selected_node[0];\n        }\n        else {\n            return null;\n        }\n    }\n    parseState(jsonData) {\n        const state = JSON.parse(jsonData);\n        // Check if selected_node is an int (instead of an array)\n        if (state && state.selected_node && isInt(state.selected_node)) {\n            // Convert to array\n            state.selected_node = [state.selected_node];\n        }\n        return state;\n    }\n    loadFromStorage() {\n        if (this.treeWidget.options.onGetStateFromStorage) {\n            return this.treeWidget.options.onGetStateFromStorage();\n        }\n        else if (this.supportsLocalStorage()) {\n            return localStorage.getItem(this.getKeyName());\n        }\n        else {\n            return null;\n        }\n    }\n    openInitialNodes(nodeIds) {\n        let mustLoadOnDemand = false;\n        for (const nodeDd of nodeIds) {\n            const node = this.treeWidget.getNodeById(nodeDd);\n            if (node) {\n                if (!node.load_on_demand) {\n                    node.is_open = true;\n                }\n                else {\n                    mustLoadOnDemand = true;\n                }\n            }\n        }\n        return mustLoadOnDemand;\n    }\n    selectInitialNodes(nodeIds) {\n        let selectCount = 0;\n        for (const nodeId of nodeIds) {\n            const node = this.treeWidget.getNodeById(nodeId);\n            if (node) {\n                selectCount += 1;\n                this.treeWidget.selectNodeHandler.addToSelection(node);\n            }\n        }\n        return selectCount !== 0;\n    }\n    resetSelection() {\n        const selectNodeHandler = this.treeWidget.selectNodeHandler;\n        const selectedNodes = selectNodeHandler.getSelectedNodes();\n        selectedNodes.forEach((node) => {\n            selectNodeHandler.removeFromSelection(node);\n        });\n    }\n    doSetInitialStateOnDemand(nodeIdsParam, selectedNodes, cbFinished) {\n        let loadingCount = 0;\n        let nodeIds = nodeIdsParam;\n        const openNodes = () => {\n            const newNodesIds = [];\n            for (const nodeId of nodeIds) {\n                const node = this.treeWidget.getNodeById(nodeId);\n                if (!node) {\n                    newNodesIds.push(nodeId);\n                }\n                else {\n                    if (!node.is_loading) {\n                        if (node.load_on_demand) {\n                            loadAndOpenNode(node);\n                        }\n                        else {\n                            this.treeWidget._openNode(node, false, null);\n                        }\n                    }\n                }\n            }\n            nodeIds = newNodesIds;\n            if (this.selectInitialNodes(selectedNodes)) {\n                this.treeWidget._refreshElements(null);\n            }\n            if (loadingCount === 0) {\n                cbFinished();\n            }\n        };\n        const loadAndOpenNode = (node) => {\n            loadingCount += 1;\n            this.treeWidget._openNode(node, false, () => {\n                loadingCount -= 1;\n                openNodes();\n            });\n        };\n        openNodes();\n    }\n    getKeyName() {\n        if (typeof this.treeWidget.options.saveState === \"string\") {\n            return this.treeWidget.options.saveState;\n        }\n        else {\n            return \"tree\";\n        }\n    }\n    supportsLocalStorage() {\n        const testSupport = () => {\n            // Is local storage supported?\n            if (localStorage == null) {\n                return false;\n            }\n            else {\n                // Check if it's possible to store an item. Safari does not allow this in private browsing mode.\n                try {\n                    const key = \"_storage_test\";\n                    sessionStorage.setItem(key, \"value\");\n                    sessionStorage.removeItem(key);\n                }\n                catch (error) {\n                    return false;\n                }\n                return true;\n            }\n        };\n        if (this._supportsLocalStorage == null) {\n            this._supportsLocalStorage = testSupport();\n        }\n        return this._supportsLocalStorage;\n    }\n}\n","export default class ScrollHandler {\n    constructor(treeWidget) {\n        this.treeWidget = treeWidget;\n        this.previousTop = -1;\n        this.isInitialized = false;\n    }\n    checkScrolling() {\n        this.ensureInit();\n        this.checkVerticalScrolling();\n        this.checkHorizontalScrolling();\n    }\n    scrollToY(top) {\n        this.ensureInit();\n        if (this.$scrollParent) {\n            this.$scrollParent[0].scrollTop = top;\n        }\n        else {\n            const offset = this.treeWidget.$el.offset();\n            const treeTop = offset ? offset.top : 0;\n            jQuery(document).scrollTop(top + treeTop);\n        }\n    }\n    isScrolledIntoView($element) {\n        this.ensureInit();\n        let elementBottom;\n        let viewBottom;\n        let elementTop;\n        let viewTop;\n        const elHeight = $element.height() || 0;\n        if (this.$scrollParent) {\n            viewTop = 0;\n            viewBottom = this.$scrollParent.height() || 0;\n            const offset = $element.offset();\n            const originalTop = offset ? offset.top : 0;\n            elementTop = originalTop - this.scrollParentTop;\n            elementBottom = elementTop + elHeight;\n        }\n        else {\n            viewTop = jQuery(window).scrollTop() || 0;\n            const windowHeight = jQuery(window).height() || 0;\n            viewBottom = viewTop + windowHeight;\n            const offset = $element.offset();\n            elementTop = offset ? offset.top : 0;\n            elementBottom = elementTop + elHeight;\n        }\n        return elementBottom <= viewBottom && elementTop >= viewTop;\n    }\n    getScrollLeft() {\n        if (!this.$scrollParent) {\n            return 0;\n        }\n        else {\n            return this.$scrollParent.scrollLeft() || 0;\n        }\n    }\n    initScrollParent() {\n        const getParentWithOverflow = () => {\n            const cssAttributes = [\"overflow\", \"overflow-y\"];\n            const hasOverFlow = ($el) => {\n                for (const attr of cssAttributes) {\n                    const overflowValue = $el.css(attr);\n                    if (overflowValue === \"auto\" ||\n                        overflowValue === \"scroll\") {\n                        return true;\n                    }\n                }\n                return false;\n            };\n            if (hasOverFlow(this.treeWidget.$el)) {\n                return this.treeWidget.$el;\n            }\n            for (const el of this.treeWidget.$el.parents().get()) {\n                const $el = jQuery(el);\n                if (hasOverFlow($el)) {\n                    return $el;\n                }\n            }\n            return null;\n        };\n        const setDocumentAsScrollParent = () => {\n            this.scrollParentTop = 0;\n            this.$scrollParent = null;\n        };\n        if (this.treeWidget.$el.css(\"position\") === \"fixed\") {\n            setDocumentAsScrollParent();\n        }\n        const $scrollParent = getParentWithOverflow();\n        if ($scrollParent &&\n            $scrollParent.length &&\n            $scrollParent[0].tagName !== \"HTML\") {\n            this.$scrollParent = $scrollParent;\n            const offset = this.$scrollParent.offset();\n            this.scrollParentTop = offset ? offset.top : 0;\n        }\n        else {\n            setDocumentAsScrollParent();\n        }\n        this.isInitialized = true;\n    }\n    ensureInit() {\n        if (!this.isInitialized) {\n            this.initScrollParent();\n        }\n    }\n    handleVerticalScrollingWithScrollParent(area) {\n        const scrollParent = this.$scrollParent && this.$scrollParent[0];\n        if (!scrollParent) {\n            return;\n        }\n        const distanceBottom = this.scrollParentTop + scrollParent.offsetHeight - area.bottom;\n        if (distanceBottom < 20) {\n            scrollParent.scrollTop += 20;\n            this.treeWidget.refreshHitAreas();\n            this.previousTop = -1;\n        }\n        else if (area.top - this.scrollParentTop < 20) {\n            scrollParent.scrollTop -= 20;\n            this.treeWidget.refreshHitAreas();\n            this.previousTop = -1;\n        }\n    }\n    handleVerticalScrollingWithDocument(area) {\n        const scrollTop = jQuery(document).scrollTop() || 0;\n        const distanceTop = area.top - scrollTop;\n        if (distanceTop < 20) {\n            jQuery(document).scrollTop(scrollTop - 20);\n        }\n        else {\n            const windowHeight = jQuery(window).height() || 0;\n            if (windowHeight - (area.bottom - scrollTop) < 20) {\n                jQuery(document).scrollTop(scrollTop + 20);\n            }\n        }\n    }\n    checkVerticalScrolling() {\n        const hoveredArea = this.treeWidget.dndHandler.hoveredArea;\n        if (hoveredArea && hoveredArea.top !== this.previousTop) {\n            this.previousTop = hoveredArea.top;\n            if (this.$scrollParent) {\n                this.handleVerticalScrollingWithScrollParent(hoveredArea);\n            }\n            else {\n                this.handleVerticalScrollingWithDocument(hoveredArea);\n            }\n        }\n    }\n    checkHorizontalScrolling() {\n        const positionInfo = this.treeWidget.dndHandler.positionInfo;\n        if (!positionInfo) {\n            return;\n        }\n        if (this.$scrollParent) {\n            this.handleHorizontalScrollingWithParent(positionInfo);\n        }\n        else {\n            this.handleHorizontalScrollingWithDocument(positionInfo);\n        }\n    }\n    handleHorizontalScrollingWithParent(positionInfo) {\n        if (positionInfo.pageX === undefined ||\n            positionInfo.pageY === undefined) {\n            return;\n        }\n        const $scrollParent = this.$scrollParent;\n        const scrollParentOffset = $scrollParent && $scrollParent.offset();\n        if (!($scrollParent && scrollParentOffset)) {\n            return;\n        }\n        const scrollParent = $scrollParent[0];\n        const canScrollRight = scrollParent.scrollLeft + scrollParent.clientWidth <\n            scrollParent.scrollWidth;\n        const canScrollLeft = scrollParent.scrollLeft > 0;\n        const rightEdge = scrollParentOffset.left + scrollParent.clientWidth;\n        const leftEdge = scrollParentOffset.left;\n        const isNearRightEdge = positionInfo.pageX > rightEdge - 20;\n        const isNearLeftEdge = positionInfo.pageX < leftEdge + 20;\n        if (isNearRightEdge && canScrollRight) {\n            scrollParent.scrollLeft = Math.min(scrollParent.scrollLeft + 20, scrollParent.scrollWidth);\n        }\n        else if (isNearLeftEdge && canScrollLeft) {\n            scrollParent.scrollLeft = Math.max(scrollParent.scrollLeft - 20, 0);\n        }\n    }\n    handleHorizontalScrollingWithDocument(positionInfo) {\n        if (positionInfo.pageX === undefined ||\n            positionInfo.pageY === undefined) {\n            return;\n        }\n        const $document = jQuery(document);\n        const scrollLeft = $document.scrollLeft() || 0;\n        const windowWidth = jQuery(window).width() || 0;\n        const canScrollLeft = scrollLeft > 0;\n        const isNearRightEdge = positionInfo.pageX > windowWidth - 20;\n        const isNearLeftEdge = positionInfo.pageX - scrollLeft < 20;\n        if (isNearRightEdge) {\n            $document.scrollLeft(scrollLeft + 20);\n        }\n        else if (isNearLeftEdge && canScrollLeft) {\n            $document.scrollLeft(Math.max(scrollLeft - 20, 0));\n        }\n    }\n}\n","export default class SelectNodeHandler {\n    constructor(treeWidget) {\n        this.treeWidget = treeWidget;\n        this.clear();\n    }\n    getSelectedNode() {\n        const selectedNodes = this.getSelectedNodes();\n        if (selectedNodes.length) {\n            return selectedNodes[0];\n        }\n        else {\n            return false;\n        }\n    }\n    getSelectedNodes() {\n        if (this.selectedSingleNode) {\n            return [this.selectedSingleNode];\n        }\n        else {\n            const selectedNodes = [];\n            for (const id in this.selectedNodes) {\n                if (Object.prototype.hasOwnProperty.call(this.selectedNodes, id)) {\n                    const node = this.treeWidget.getNodeById(id);\n                    if (node) {\n                        selectedNodes.push(node);\n                    }\n                }\n            }\n            return selectedNodes;\n        }\n    }\n    getSelectedNodesUnder(parent) {\n        if (this.selectedSingleNode) {\n            if (parent.isParentOf(this.selectedSingleNode)) {\n                return [this.selectedSingleNode];\n            }\n            else {\n                return [];\n            }\n        }\n        else {\n            const selectedNodes = [];\n            for (const id in this.selectedNodes) {\n                if (Object.prototype.hasOwnProperty.call(this.selectedNodes, id)) {\n                    const node = this.treeWidget.getNodeById(id);\n                    if (node && parent.isParentOf(node)) {\n                        selectedNodes.push(node);\n                    }\n                }\n            }\n            return selectedNodes;\n        }\n    }\n    isNodeSelected(node) {\n        if (node.id != null) {\n            if (this.selectedNodes[node.id]) {\n                return true;\n            }\n            else {\n                return false;\n            }\n        }\n        else if (this.selectedSingleNode) {\n            return this.selectedSingleNode.element === node.element;\n        }\n        else {\n            return false;\n        }\n    }\n    clear() {\n        this.selectedNodes = {};\n        this.selectedSingleNode = null;\n    }\n    removeFromSelection(node, includeChildren = false) {\n        if (node.id == null) {\n            if (this.selectedSingleNode &&\n                node.element === this.selectedSingleNode.element) {\n                this.selectedSingleNode = null;\n            }\n        }\n        else {\n            delete this.selectedNodes[node.id];\n            if (includeChildren) {\n                node.iterate(() => {\n                    if (node.id != null) {\n                        delete this.selectedNodes[node.id];\n                    }\n                    return true;\n                });\n            }\n        }\n    }\n    addToSelection(node) {\n        if (node.id != null) {\n            this.selectedNodes[node.id] = true;\n        }\n        else {\n            this.selectedSingleNode = node;\n        }\n    }\n}\n","import { Position } from \"./node\";\nexport class NodeElement {\n    constructor(node, treeWidget) {\n        this.init(node, treeWidget);\n    }\n    init(node, treeWidget) {\n        this.node = node;\n        this.treeWidget = treeWidget;\n        if (!node.element) {\n            node.element = this.treeWidget.element.get(0);\n        }\n        this.$element = jQuery(node.element);\n    }\n    addDropHint(position) {\n        if (this.mustShowBorderDropHint(position)) {\n            return new BorderDropHint(this.$element, this.treeWidget._getScrollLeft());\n        }\n        else {\n            return new GhostDropHint(this.node, this.$element, position);\n        }\n    }\n    select(mustSetFocus) {\n        var _a;\n        const $li = this.getLi();\n        $li.addClass(\"jqtree-selected\");\n        $li.attr(\"aria-selected\", \"true\");\n        const $span = this.getSpan();\n        $span.attr(\"tabindex\", (_a = this.treeWidget.options.tabIndex) !== null && _a !== void 0 ? _a : null);\n        if (mustSetFocus) {\n            $span.focus();\n        }\n    }\n    deselect() {\n        const $li = this.getLi();\n        $li.removeClass(\"jqtree-selected\");\n        $li.attr(\"aria-selected\", \"false\");\n        const $span = this.getSpan();\n        $span.removeAttr(\"tabindex\");\n        $span.blur();\n    }\n    getUl() {\n        return this.$element.children(\"ul:first\");\n    }\n    getSpan() {\n        return this.$element\n            .children(\".jqtree-element\")\n            .find(\"span.jqtree-title\");\n    }\n    getLi() {\n        return this.$element;\n    }\n    mustShowBorderDropHint(position) {\n        return position === Position.Inside;\n    }\n}\nexport class FolderElement extends NodeElement {\n    open(onFinished, slide = true, animationSpeed = \"fast\") {\n        if (this.node.is_open) {\n            return;\n        }\n        this.node.is_open = true;\n        const $button = this.getButton();\n        $button.removeClass(\"jqtree-closed\");\n        $button.html(\"\");\n        const buttonEl = $button.get(0);\n        if (buttonEl) {\n            const icon = this.treeWidget.renderer.openedIconElement.cloneNode(true);\n            buttonEl.appendChild(icon);\n        }\n        const doOpen = () => {\n            const $li = this.getLi();\n            $li.removeClass(\"jqtree-closed\");\n            const $span = this.getSpan();\n            $span.attr(\"aria-expanded\", \"true\");\n            if (onFinished) {\n                onFinished(this.node);\n            }\n            this.treeWidget._triggerEvent(\"tree.open\", {\n                node: this.node,\n            });\n        };\n        if (slide) {\n            this.getUl().slideDown(animationSpeed, doOpen);\n        }\n        else {\n            this.getUl().show();\n            doOpen();\n        }\n    }\n    close(slide = true, animationSpeed = \"fast\") {\n        if (!this.node.is_open) {\n            return;\n        }\n        this.node.is_open = false;\n        const $button = this.getButton();\n        $button.addClass(\"jqtree-closed\");\n        $button.html(\"\");\n        const buttonEl = $button.get(0);\n        if (buttonEl) {\n            const icon = this.treeWidget.renderer.closedIconElement.cloneNode(true);\n            buttonEl.appendChild(icon);\n        }\n        const doClose = () => {\n            const $li = this.getLi();\n            $li.addClass(\"jqtree-closed\");\n            const $span = this.getSpan();\n            $span.attr(\"aria-expanded\", \"false\");\n            this.treeWidget._triggerEvent(\"tree.close\", {\n                node: this.node,\n            });\n        };\n        if (slide) {\n            this.getUl().slideUp(animationSpeed, doClose);\n        }\n        else {\n            this.getUl().hide();\n            doClose();\n        }\n    }\n    mustShowBorderDropHint(position) {\n        return !this.node.is_open && position === Position.Inside;\n    }\n    getButton() {\n        return this.$element\n            .children(\".jqtree-element\")\n            .find(\"a.jqtree-toggler\");\n    }\n}\nexport class BorderDropHint {\n    constructor($element, scrollLeft) {\n        const $div = $element.children(\".jqtree-element\");\n        const elWidth = $element.width() || 0;\n        const width = Math.max(elWidth + scrollLeft - 4, 0);\n        const elHeight = $div.outerHeight() || 0;\n        const height = Math.max(elHeight - 4, 0);\n        this.$hint = jQuery('<span class=\"jqtree-border\"></span>');\n        $div.append(this.$hint);\n        this.$hint.css({ width, height });\n    }\n    remove() {\n        this.$hint.remove();\n    }\n}\nclass GhostDropHint {\n    constructor(node, $element, position) {\n        this.$element = $element;\n        this.node = node;\n        this.$ghost = jQuery(`<li class=\"jqtree_common jqtree-ghost\"><span class=\"jqtree_common jqtree-circle\"></span>\n            <span class=\"jqtree_common jqtree-line\"></span></li>`);\n        if (position === Position.After) {\n            this.moveAfter();\n        }\n        else if (position === Position.Before) {\n            this.moveBefore();\n        }\n        else if (position === Position.Inside) {\n            if (node.isFolder() && node.is_open) {\n                this.moveInsideOpenFolder();\n            }\n            else {\n                this.moveInside();\n            }\n        }\n    }\n    remove() {\n        this.$ghost.remove();\n    }\n    moveAfter() {\n        this.$element.after(this.$ghost);\n    }\n    moveBefore() {\n        this.$element.before(this.$ghost);\n    }\n    moveInsideOpenFolder() {\n        jQuery(this.node.children[0].element).before(this.$ghost);\n    }\n    moveInside() {\n        this.$element.after(this.$ghost);\n        this.$ghost.addClass(\"jqtree-inside\");\n    }\n}\n","import __version__ from \"./version\";\nimport * as jQuery from \"jquery\";\nimport { DragAndDropHandler } from \"./dragAndDropHandler\";\nimport ElementsRenderer from \"./elementsRenderer\";\nimport DataLoader from \"./dataLoader\";\nimport KeyHandler from \"./keyHandler\";\nimport MouseWidget from \"./mouse.widget\";\nimport SaveStateHandler from \"./saveStateHandler\";\nimport ScrollHandler from \"./scrollHandler\";\nimport SelectNodeHandler from \"./selectNodeHandler\";\nimport SimpleWidget from \"./simple.widget\";\nimport { Node, getPosition } from \"./node\";\nimport { isFunction } from \"./util\";\nimport { FolderElement, NodeElement } from \"./nodeElement\";\nconst NODE_PARAM_IS_EMPTY = \"Node parameter is empty\";\nconst PARAM_IS_EMPTY = \"Parameter is empty: \";\nexport class JqTreeWidget extends MouseWidget {\n    constructor() {\n        super(...arguments);\n        this.handleClick = (e) => {\n            const clickTarget = this.getClickTarget(e.target);\n            if (clickTarget) {\n                if (clickTarget.type === \"button\") {\n                    this.toggle(clickTarget.node, this.options.slide);\n                    e.preventDefault();\n                    e.stopPropagation();\n                }\n                else if (clickTarget.type === \"label\") {\n                    const node = clickTarget.node;\n                    const event = this._triggerEvent(\"tree.click\", {\n                        node,\n                        click_event: e,\n                    });\n                    if (!event.isDefaultPrevented()) {\n                        this.doSelectNode(node);\n                    }\n                }\n            }\n        };\n        this.handleDblclick = (e) => {\n            const clickTarget = this.getClickTarget(e.target);\n            if ((clickTarget === null || clickTarget === void 0 ? void 0 : clickTarget.type) === \"label\") {\n                this._triggerEvent(\"tree.dblclick\", {\n                    node: clickTarget.node,\n                    click_event: e,\n                });\n            }\n        };\n        this.handleContextmenu = (e) => {\n            const $div = jQuery(e.target).closest(\"ul.jqtree-tree .jqtree-element\");\n            if ($div.length) {\n                const node = this.getNode($div);\n                if (node) {\n                    e.preventDefault();\n                    e.stopPropagation();\n                    this._triggerEvent(\"tree.contextmenu\", {\n                        node,\n                        click_event: e,\n                    });\n                    return false;\n                }\n            }\n            return null;\n        };\n    }\n    toggle(node, slideParam = null) {\n        if (!node) {\n            throw Error(NODE_PARAM_IS_EMPTY);\n        }\n        const slide = slideParam !== null && slideParam !== void 0 ? slideParam : this.options.slide;\n        if (node.is_open) {\n            this.closeNode(node, slide);\n        }\n        else {\n            this.openNode(node, slide);\n        }\n        return this.element;\n    }\n    getTree() {\n        return this.tree;\n    }\n    selectNode(node, optionsParam) {\n        this.doSelectNode(node, optionsParam);\n        return this.element;\n    }\n    getSelectedNode() {\n        return this.selectNodeHandler.getSelectedNode();\n    }\n    toJson() {\n        return JSON.stringify(this.tree.getData());\n    }\n    loadData(data, parentNode) {\n        this.doLoadData(data, parentNode);\n        return this.element;\n    }\n    /*\n    signatures:\n    - loadDataFromUrl(url, parent_node=null, on_finished=null)\n        loadDataFromUrl('/my_data');\n        loadDataFromUrl('/my_data', node1);\n        loadDataFromUrl('/my_data', node1, function() { console.log('finished'); });\n        loadDataFromUrl('/my_data', null, function() { console.log('finished'); });\n\n    - loadDataFromUrl(parent_node=null, on_finished=null)\n        loadDataFromUrl();\n        loadDataFromUrl(node1);\n        loadDataFromUrl(null, function() { console.log('finished'); });\n        loadDataFromUrl(node1, function() { console.log('finished'); });\n    */\n    loadDataFromUrl(param1, param2, param3) {\n        if (typeof param1 === \"string\") {\n            // first parameter is url\n            this.doLoadDataFromUrl(param1, param2, param3 !== null && param3 !== void 0 ? param3 : null);\n        }\n        else {\n            // first parameter is not url\n            this.doLoadDataFromUrl(null, param1, param2);\n        }\n        return this.element;\n    }\n    reload(onFinished) {\n        this.doLoadDataFromUrl(null, null, onFinished);\n        return this.element;\n    }\n    getNodeById(nodeId) {\n        return this.tree.getNodeById(nodeId);\n    }\n    getNodeByName(name) {\n        return this.tree.getNodeByName(name);\n    }\n    getNodeByNameMustExist(name) {\n        return this.tree.getNodeByNameMustExist(name);\n    }\n    getNodesByProperty(key, value) {\n        return this.tree.getNodesByProperty(key, value);\n    }\n    getNodeByHtmlElement(element) {\n        return this.getNode(jQuery(element));\n    }\n    getNodeByCallback(callback) {\n        return this.tree.getNodeByCallback(callback);\n    }\n    openNode(node, param1, param2) {\n        if (!node) {\n            throw Error(NODE_PARAM_IS_EMPTY);\n        }\n        const parseParams = () => {\n            var _a;\n            let onFinished;\n            let slide;\n            if (isFunction(param1)) {\n                onFinished = param1;\n                slide = null;\n            }\n            else {\n                slide = param1;\n                onFinished = param2;\n            }\n            if (slide == null) {\n                slide = (_a = this.options.slide) !== null && _a !== void 0 ? _a : false;\n            }\n            return [slide, onFinished];\n        };\n        const [slide, onFinished] = parseParams();\n        this._openNode(node, slide, onFinished);\n        return this.element;\n    }\n    closeNode(node, slideParam) {\n        if (!node) {\n            throw Error(NODE_PARAM_IS_EMPTY);\n        }\n        const slide = slideParam !== null && slideParam !== void 0 ? slideParam : this.options.slide;\n        if (node.isFolder() || node.isEmptyFolder) {\n            new FolderElement(node, this).close(slide, this.options.animationSpeed);\n            this.saveState();\n        }\n        return this.element;\n    }\n    isDragging() {\n        return this.dndHandler.isDragging;\n    }\n    refreshHitAreas() {\n        this.dndHandler.refresh();\n        return this.element;\n    }\n    addNodeAfter(newNodeInfo, existingNode) {\n        const newNode = existingNode.addAfter(newNodeInfo);\n        if (newNode) {\n            this._refreshElements(existingNode.parent);\n        }\n        return newNode;\n    }\n    addNodeBefore(newNodeInfo, existingNode) {\n        if (!existingNode) {\n            throw Error(PARAM_IS_EMPTY + \"existingNode\");\n        }\n        const newNode = existingNode.addBefore(newNodeInfo);\n        if (newNode) {\n            this._refreshElements(existingNode.parent);\n        }\n        return newNode;\n    }\n    addParentNode(newNodeInfo, existingNode) {\n        if (!existingNode) {\n            throw Error(PARAM_IS_EMPTY + \"existingNode\");\n        }\n        const newNode = existingNode.addParent(newNodeInfo);\n        if (newNode) {\n            this._refreshElements(newNode.parent);\n        }\n        return newNode;\n    }\n    removeNode(node) {\n        if (!node) {\n            throw Error(NODE_PARAM_IS_EMPTY);\n        }\n        if (!node.parent) {\n            throw Error(\"Node has no parent\");\n        }\n        this.selectNodeHandler.removeFromSelection(node, true); // including children\n        const parent = node.parent;\n        node.remove();\n        this._refreshElements(parent);\n        return this.element;\n    }\n    appendNode(newNodeInfo, parentNodeParam) {\n        const parentNode = parentNodeParam || this.tree;\n        const node = parentNode.append(newNodeInfo);\n        this._refreshElements(parentNode);\n        return node;\n    }\n    prependNode(newNodeInfo, parentNodeParam) {\n        const parentNode = parentNodeParam !== null && parentNodeParam !== void 0 ? parentNodeParam : this.tree;\n        const node = parentNode.prepend(newNodeInfo);\n        this._refreshElements(parentNode);\n        return node;\n    }\n    updateNode(node, data) {\n        if (!node) {\n            throw Error(NODE_PARAM_IS_EMPTY);\n        }\n        const idIsChanged = typeof data === \"object\" && data.id && data.id !== node.id;\n        if (idIsChanged) {\n            this.tree.removeNodeFromIndex(node);\n        }\n        node.setData(data);\n        if (idIsChanged) {\n            this.tree.addNodeToIndex(node);\n        }\n        if (typeof data === \"object\" &&\n            data[\"children\"] &&\n            data[\"children\"] instanceof Array) {\n            node.removeChildren();\n            if (data.children.length) {\n                node.loadFromData(data.children);\n            }\n        }\n        this._refreshElements(node);\n        this.selectCurrentNode();\n        return this.element;\n    }\n    moveNode(node, targetNode, position) {\n        if (!node) {\n            throw Error(NODE_PARAM_IS_EMPTY);\n        }\n        if (!targetNode) {\n            throw Error(PARAM_IS_EMPTY + \"targetNode\");\n        }\n        const positionIndex = getPosition(position);\n        if (positionIndex !== undefined) {\n            this.tree.moveNode(node, targetNode, positionIndex);\n            this._refreshElements(null);\n        }\n        return this.element;\n    }\n    getStateFromStorage() {\n        return this.saveStateHandler.getStateFromStorage();\n    }\n    addToSelection(node, mustSetFocus) {\n        if (!node) {\n            throw Error(NODE_PARAM_IS_EMPTY);\n        }\n        this.selectNodeHandler.addToSelection(node);\n        this._getNodeElementForNode(node).select(mustSetFocus === undefined ? true : mustSetFocus);\n        this.saveState();\n        return this.element;\n    }\n    getSelectedNodes() {\n        return this.selectNodeHandler.getSelectedNodes();\n    }\n    isNodeSelected(node) {\n        if (!node) {\n            throw Error(NODE_PARAM_IS_EMPTY);\n        }\n        return this.selectNodeHandler.isNodeSelected(node);\n    }\n    removeFromSelection(node) {\n        if (!node) {\n            throw Error(NODE_PARAM_IS_EMPTY);\n        }\n        this.selectNodeHandler.removeFromSelection(node);\n        this._getNodeElementForNode(node).deselect();\n        this.saveState();\n        return this.element;\n    }\n    scrollToNode(node) {\n        if (!node) {\n            throw Error(NODE_PARAM_IS_EMPTY);\n        }\n        const nodeOffset = jQuery(node.element).offset();\n        const nodeTop = nodeOffset ? nodeOffset.top : 0;\n        const treeOffset = this.$el.offset();\n        const treeTop = treeOffset ? treeOffset.top : 0;\n        const top = nodeTop - treeTop;\n        this.scrollHandler.scrollToY(top);\n        return this.element;\n    }\n    getState() {\n        return this.saveStateHandler.getState();\n    }\n    setState(state) {\n        this.saveStateHandler.setInitialState(state);\n        this._refreshElements(null);\n        return this.element;\n    }\n    setOption(option, value) {\n        this.options[option] = value;\n        return this.element;\n    }\n    moveDown() {\n        const selectedNode = this.getSelectedNode();\n        if (selectedNode) {\n            this.keyHandler.moveDown(selectedNode);\n        }\n        return this.element;\n    }\n    moveUp() {\n        const selectedNode = this.getSelectedNode();\n        if (selectedNode) {\n            this.keyHandler.moveUp(selectedNode);\n        }\n        return this.element;\n    }\n    getVersion() {\n        return __version__;\n    }\n    _triggerEvent(eventName, values) {\n        const event = jQuery.Event(eventName, values);\n        this.element.trigger(event);\n        return event;\n    }\n    _openNode(node, slide = true, onFinished) {\n        const doOpenNode = (_node, _slide, _onFinished) => {\n            const folderElement = new FolderElement(_node, this);\n            folderElement.open(_onFinished, _slide, this.options.animationSpeed);\n        };\n        if (node.isFolder() || node.isEmptyFolder) {\n            if (node.load_on_demand) {\n                this.loadFolderOnDemand(node, slide, onFinished);\n            }\n            else {\n                let parent = node.parent;\n                while (parent) {\n                    // nb: do not open root element\n                    if (parent.parent) {\n                        doOpenNode(parent, false, null);\n                    }\n                    parent = parent.parent;\n                }\n                doOpenNode(node, slide, onFinished);\n                this.saveState();\n            }\n        }\n    }\n    /*\n    Redraw the tree or part of the tree.\n     from_node: redraw this subtree\n    */\n    _refreshElements(fromNode) {\n        this.renderer.render(fromNode);\n        this._triggerEvent(\"tree.refresh\");\n    }\n    _getNodeElementForNode(node) {\n        if (node.isFolder()) {\n            return new FolderElement(node, this);\n        }\n        else {\n            return new NodeElement(node, this);\n        }\n    }\n    _getNodeElement($element) {\n        const node = this.getNode($element);\n        if (node) {\n            return this._getNodeElementForNode(node);\n        }\n        else {\n            return null;\n        }\n    }\n    _containsElement(element) {\n        const node = this.getNode(jQuery(element));\n        return node != null && node.tree === this.tree;\n    }\n    _getScrollLeft() {\n        return this.scrollHandler.getScrollLeft();\n    }\n    init() {\n        super.init();\n        this.element = this.$el;\n        this.mouseDelay = 300;\n        this.isInitialized = false;\n        this.options.rtl = this.getRtlOption();\n        if (this.options.closedIcon == null) {\n            this.options.closedIcon = this.getDefaultClosedIcon();\n        }\n        this.renderer = new ElementsRenderer(this);\n        this.dataLoader = new DataLoader(this);\n        this.saveStateHandler = new SaveStateHandler(this);\n        this.selectNodeHandler = new SelectNodeHandler(this);\n        this.dndHandler = new DragAndDropHandler(this);\n        this.scrollHandler = new ScrollHandler(this);\n        this.keyHandler = new KeyHandler(this);\n        this.initData();\n        this.element.on(\"click\", this.handleClick);\n        this.element.on(\"dblclick\", this.handleDblclick);\n        if (this.options.useContextMenu) {\n            this.element.on(\"contextmenu\", this.handleContextmenu);\n        }\n    }\n    deinit() {\n        this.element.empty();\n        this.element.off();\n        this.keyHandler.deinit();\n        this.tree = new Node({}, true);\n        super.deinit();\n    }\n    mouseCapture(positionInfo) {\n        if (this.options.dragAndDrop) {\n            return this.dndHandler.mouseCapture(positionInfo);\n        }\n        else {\n            return false;\n        }\n    }\n    mouseStart(positionInfo) {\n        if (this.options.dragAndDrop) {\n            return this.dndHandler.mouseStart(positionInfo);\n        }\n        else {\n            return false;\n        }\n    }\n    mouseDrag(positionInfo) {\n        if (this.options.dragAndDrop) {\n            const result = this.dndHandler.mouseDrag(positionInfo);\n            this.scrollHandler.checkScrolling();\n            return result;\n        }\n        else {\n            return false;\n        }\n    }\n    mouseStop(positionInfo) {\n        if (this.options.dragAndDrop) {\n            return this.dndHandler.mouseStop(positionInfo);\n        }\n        else {\n            return false;\n        }\n    }\n    initData() {\n        if (this.options.data) {\n            this.doLoadData(this.options.data, null);\n        }\n        else {\n            const dataUrl = this.getDataUrlInfo(null);\n            if (dataUrl) {\n                this.doLoadDataFromUrl(null, null, null);\n            }\n            else {\n                this.doLoadData([], null);\n            }\n        }\n    }\n    getDataUrlInfo(node) {\n        const dataUrl = this.options.dataUrl || this.element.data(\"url\");\n        const getUrlFromString = (url) => {\n            const urlInfo = { url };\n            setUrlInfoData(urlInfo);\n            return urlInfo;\n        };\n        const setUrlInfoData = (urlInfo) => {\n            if (node === null || node === void 0 ? void 0 : node.id) {\n                // Load on demand of a subtree; add node parameter\n                const data = { node: node.id };\n                urlInfo[\"data\"] = data;\n            }\n            else {\n                // Add selected_node parameter\n                const selectedNodeId = this.getNodeIdToBeSelected();\n                if (selectedNodeId) {\n                    const data = { selected_node: selectedNodeId };\n                    urlInfo[\"data\"] = data;\n                }\n            }\n        };\n        if (typeof dataUrl === \"function\") {\n            return dataUrl(node);\n        }\n        else if (typeof dataUrl === \"string\") {\n            return getUrlFromString(dataUrl);\n        }\n        else if (dataUrl && typeof dataUrl === \"object\") {\n            setUrlInfoData(dataUrl);\n            return dataUrl;\n        }\n        else {\n            return null;\n        }\n    }\n    getNodeIdToBeSelected() {\n        if (this.options.saveState) {\n            return this.saveStateHandler.getNodeIdToBeSelected();\n        }\n        else {\n            return null;\n        }\n    }\n    initTree(data) {\n        const doInit = () => {\n            if (!this.isInitialized) {\n                this.isInitialized = true;\n                this._triggerEvent(\"tree.init\");\n            }\n        };\n        if (!this.options.nodeClass) {\n            return;\n        }\n        this.tree = new this.options.nodeClass(null, true, this.options.nodeClass);\n        this.selectNodeHandler.clear();\n        this.tree.loadFromData(data);\n        const mustLoadOnDemand = this.setInitialState();\n        this._refreshElements(null);\n        if (!mustLoadOnDemand) {\n            doInit();\n        }\n        else {\n            // Load data on demand and then init the tree\n            this.setInitialStateOnDemand(doInit);\n        }\n    }\n    // Set initial state, either by restoring the state or auto-opening nodes\n    // result: must load nodes on demand?\n    setInitialState() {\n        const restoreState = () => {\n            // result: is state restored, must load on demand?\n            if (!this.options.saveState) {\n                return [false, false];\n            }\n            else {\n                const state = this.saveStateHandler.getStateFromStorage();\n                if (!state) {\n                    return [false, false];\n                }\n                else {\n                    const mustLoadOnDemand = this.saveStateHandler.setInitialState(state);\n                    // return true: the state is restored\n                    return [true, mustLoadOnDemand];\n                }\n            }\n        };\n        const autoOpenNodes = () => {\n            // result: must load on demand?\n            if (this.options.autoOpen === false) {\n                return false;\n            }\n            const maxLevel = this.getAutoOpenMaxLevel();\n            let mustLoadOnDemand = false;\n            this.tree.iterate((node, level) => {\n                if (node.load_on_demand) {\n                    mustLoadOnDemand = true;\n                    return false;\n                }\n                else if (!node.hasChildren()) {\n                    return false;\n                }\n                else {\n                    node.is_open = true;\n                    return level !== maxLevel;\n                }\n            });\n            return mustLoadOnDemand;\n        };\n        let [isRestored, mustLoadOnDemand] = restoreState(); // eslint-disable-line prefer-const\n        if (!isRestored) {\n            mustLoadOnDemand = autoOpenNodes();\n        }\n        return mustLoadOnDemand;\n    }\n    // Set the initial state for nodes that are loaded on demand\n    // Call cb_finished when done\n    setInitialStateOnDemand(cbFinished) {\n        const restoreState = () => {\n            if (!this.options.saveState) {\n                return false;\n            }\n            else {\n                const state = this.saveStateHandler.getStateFromStorage();\n                if (!state) {\n                    return false;\n                }\n                else {\n                    this.saveStateHandler.setInitialStateOnDemand(state, cbFinished);\n                    return true;\n                }\n            }\n        };\n        const autoOpenNodes = () => {\n            const maxLevel = this.getAutoOpenMaxLevel();\n            let loadingCount = 0;\n            const loadAndOpenNode = (node) => {\n                loadingCount += 1;\n                this._openNode(node, false, () => {\n                    loadingCount -= 1;\n                    openNodes();\n                });\n            };\n            const openNodes = () => {\n                this.tree.iterate((node, level) => {\n                    if (node.load_on_demand) {\n                        if (!node.is_loading) {\n                            loadAndOpenNode(node);\n                        }\n                        return false;\n                    }\n                    else {\n                        this._openNode(node, false, null);\n                        return level !== maxLevel;\n                    }\n                });\n                if (loadingCount === 0) {\n                    cbFinished();\n                }\n            };\n            openNodes();\n        };\n        if (!restoreState()) {\n            autoOpenNodes();\n        }\n    }\n    getAutoOpenMaxLevel() {\n        if (this.options.autoOpen === true) {\n            return -1;\n        }\n        else if (typeof this.options.autoOpen === \"number\") {\n            return this.options.autoOpen;\n        }\n        else if (typeof this.options.autoOpen === \"string\") {\n            return parseInt(this.options.autoOpen, 10);\n        }\n        else {\n            return 0;\n        }\n    }\n    getClickTarget(element) {\n        const $target = jQuery(element);\n        const $button = $target.closest(\".jqtree-toggler\");\n        if ($button.length) {\n            const node = this.getNode($button);\n            if (node) {\n                return {\n                    type: \"button\",\n                    node,\n                };\n            }\n        }\n        else {\n            const $el = $target.closest(\".jqtree-element\");\n            if ($el.length) {\n                const node = this.getNode($el);\n                if (node) {\n                    return {\n                        type: \"label\",\n                        node,\n                    };\n                }\n            }\n        }\n        return null;\n    }\n    getNode($element) {\n        const $li = $element.closest(\"li.jqtree_common\");\n        if ($li.length === 0) {\n            return null;\n        }\n        else {\n            return $li.data(\"node\");\n        }\n    }\n    saveState() {\n        if (this.options.saveState) {\n            this.saveStateHandler.saveState();\n        }\n    }\n    selectCurrentNode() {\n        const node = this.getSelectedNode();\n        if (node) {\n            const nodeElement = this._getNodeElementForNode(node);\n            if (nodeElement) {\n                nodeElement.select(true);\n            }\n        }\n    }\n    deselectCurrentNode() {\n        const node = this.getSelectedNode();\n        if (node) {\n            this.removeFromSelection(node);\n        }\n    }\n    getDefaultClosedIcon() {\n        if (this.options.rtl) {\n            // triangle to the left\n            return \"&#x25c0;\";\n        }\n        else {\n            // triangle to the right\n            return \"&#x25ba;\";\n        }\n    }\n    getRtlOption() {\n        if (this.options.rtl != null) {\n            return this.options.rtl;\n        }\n        else {\n            const dataRtl = this.element.data(\"rtl\");\n            if (dataRtl !== null &&\n                dataRtl !== false &&\n                dataRtl !== undefined) {\n                return true;\n            }\n            else {\n                return false;\n            }\n        }\n    }\n    doSelectNode(node, optionsParam) {\n        const saveState = () => {\n            if (this.options.saveState) {\n                this.saveStateHandler.saveState();\n            }\n        };\n        if (!node) {\n            // Called with empty node -> deselect current node\n            this.deselectCurrentNode();\n            saveState();\n            return;\n        }\n        const defaultOptions = { mustSetFocus: true, mustToggle: true };\n        const selectOptions = Object.assign(Object.assign({}, defaultOptions), (optionsParam || {}));\n        const canSelect = () => {\n            if (this.options.onCanSelectNode) {\n                return (this.options.selectable === true &&\n                    this.options.onCanSelectNode(node));\n            }\n            else {\n                return this.options.selectable === true;\n            }\n        };\n        const openParents = () => {\n            const parent = node.parent;\n            if (parent && parent.parent && !parent.is_open) {\n                this.openNode(parent, false);\n            }\n        };\n        if (!canSelect()) {\n            return;\n        }\n        if (this.selectNodeHandler.isNodeSelected(node)) {\n            if (selectOptions.mustToggle) {\n                this.deselectCurrentNode();\n                this._triggerEvent(\"tree.select\", {\n                    node: null,\n                    previous_node: node,\n                });\n            }\n        }\n        else {\n            const deselectedNode = this.getSelectedNode() || null;\n            this.deselectCurrentNode();\n            this.addToSelection(node, selectOptions.mustSetFocus);\n            this._triggerEvent(\"tree.select\", {\n                node,\n                deselected_node: deselectedNode,\n            });\n            openParents();\n        }\n        saveState();\n    }\n    doLoadData(data, parentNode) {\n        if (!data) {\n            return;\n        }\n        else {\n            this._triggerEvent(\"tree.load_data\", { tree_data: data });\n            if (parentNode) {\n                this.deselectNodes(parentNode);\n                this.loadSubtree(data, parentNode);\n            }\n            else {\n                this.initTree(data);\n            }\n            if (this.isDragging()) {\n                this.dndHandler.refresh();\n            }\n        }\n    }\n    deselectNodes(parentNode) {\n        const selectedNodesUnderParent = this.selectNodeHandler.getSelectedNodesUnder(parentNode);\n        for (const n of selectedNodesUnderParent) {\n            this.selectNodeHandler.removeFromSelection(n);\n        }\n    }\n    loadSubtree(data, parentNode) {\n        parentNode.loadFromData(data);\n        parentNode.load_on_demand = false;\n        parentNode.is_loading = false;\n        this._refreshElements(parentNode);\n    }\n    doLoadDataFromUrl(urlInfoParam, parentNode, onFinished) {\n        const urlInfo = urlInfoParam || this.getDataUrlInfo(parentNode);\n        this.dataLoader.loadFromUrl(urlInfo, parentNode, onFinished);\n    }\n    loadFolderOnDemand(node, slide = true, onFinished) {\n        node.is_loading = true;\n        this.doLoadDataFromUrl(null, node, () => {\n            this._openNode(node, slide, onFinished);\n        });\n    }\n}\nJqTreeWidget.defaults = {\n    animationSpeed: \"fast\",\n    autoOpen: false,\n    saveState: false,\n    dragAndDrop: false,\n    selectable: true,\n    useContextMenu: true,\n    onCanSelectNode: undefined,\n    onSetStateFromStorage: undefined,\n    onGetStateFromStorage: undefined,\n    onCreateLi: undefined,\n    onIsMoveHandle: undefined,\n    // Can this node be moved?\n    onCanMove: undefined,\n    // Can this node be moved to this position? function(moved_node, target_node, position)\n    onCanMoveTo: undefined,\n    onLoadFailed: undefined,\n    autoEscape: true,\n    dataUrl: undefined,\n    // The symbol to use for a closed node -  BLACK RIGHT-POINTING POINTER\n    // http://www.fileformat.info/info/unicode/char/25ba/index.htm\n    closedIcon: undefined,\n    // The symbol to use for an open node -  BLACK DOWN-POINTING TRIANGLE\n    // http://www.fileformat.info/info/unicode/char/25bc/index.htm\n    openedIcon: \"&#x25bc;\",\n    slide: true,\n    nodeClass: Node,\n    dataFilter: undefined,\n    keyboardSupport: true,\n    openFolderDelay: 500,\n    rtl: undefined,\n    onDragMove: undefined,\n    onDragStop: undefined,\n    buttonLeft: true,\n    onLoading: undefined,\n    showEmptyFolder: false,\n    tabIndex: 0,\n};\nSimpleWidget.register(JqTreeWidget, \"tree\");\n"],"sourceRoot":""}