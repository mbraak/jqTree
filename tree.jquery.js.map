{"version":3,"file":"tree.jquery.js","sources":["node_modules/tslib/tslib.es6.js","src/node.ts","src/dragAndDropHandler.ts","src/util.ts","src/elementsRenderer.ts","src/dataLoader.ts","src/keyHandler.ts","src/simple.widget.ts","src/mouse.widget.ts","src/saveStateHandler.ts","src/scrollHandler.ts","src/selectNodeHandler.ts","src/nodeElement.ts","src/tree.jquery.ts","src/version.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","export type NodeId = number | string;\n\nexport type DefaultRecord = Record<string, unknown>;\nexport type NodeData = string | DefaultRecord;\n\nexport enum Position {\n    Before = 1,\n    After,\n    Inside,\n    None,\n}\n\nconst positionNames: Record<string, Position> = {\n    before: Position.Before,\n    after: Position.After,\n    inside: Position.Inside,\n    none: Position.None,\n};\n\ntype IterateCallback = (node: Node, level: number) => boolean;\n\nexport const getPositionName = (position: Position): string => {\n    for (const name in positionNames) {\n        if (Object.prototype.hasOwnProperty.call(positionNames, name)) {\n            if (positionNames[name] === position) {\n                return name;\n            }\n        }\n    }\n\n    return \"\";\n};\n\nexport const getPosition = (name: string): Position | undefined =>\n    positionNames[name];\n\nexport class Node implements INode {\n    public id?: NodeId;\n    public name: string;\n    public children: Node[];\n    public parent: Node | null;\n    public idMapping: Record<NodeId, Node>;\n    public tree?: Node;\n    public nodeClass?: typeof Node;\n    public load_on_demand: boolean;\n    public is_open: boolean;\n    public element: HTMLElement;\n    public is_loading: boolean;\n    public isEmptyFolder: boolean;\n\n    [key: string]: unknown;\n\n    constructor(o: NodeData | null = null, isRoot = false, nodeClass = Node) {\n        this.name = \"\";\n        this.isEmptyFolder = false;\n        this.load_on_demand = false;\n\n        this.setData(o);\n\n        this.children = [];\n        this.parent = null;\n\n        if (isRoot) {\n            this.idMapping = {};\n            this.tree = this;\n            this.nodeClass = nodeClass;\n        }\n    }\n\n    /*\n    Set the data of this node.\n\n    setData(string): set the name of the node\n    setdata(object): set attributes of the node\n\n    Examples:\n        setdata('node1')\n\n        setData({ name: 'node1', id: 1});\n\n        setData({ name: 'node2', id: 2, color: 'green'});\n\n    * This is an internal function; it is not in the docs\n    * Does not remove existing node values\n    */\n    public setData(o: NodeData | null): void {\n        if (!o) {\n            return;\n        } else if (typeof o === \"string\") {\n            this.name = o;\n        } else if (typeof o === \"object\") {\n            for (const key in o) {\n                if (Object.prototype.hasOwnProperty.call(o, key)) {\n                    const value = o[key];\n\n                    if (key === \"label\" || key === \"name\") {\n                        // You can use the 'label' key instead of 'name'; this is a legacy feature\n                        if (typeof value === \"string\") {\n                            this.name = value;\n                        }\n                    } else if (key !== \"children\" && key !== \"parent\") {\n                        // You can't update the children or the parent using this function\n                        this[key] = value;\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n    Create tree from data.\n\n    Structure of data is:\n    [\n        {\n            name: 'node1',\n            children: [\n                { name: 'child1' },\n                { name: 'child2' }\n            ]\n        },\n        {\n            name: 'node2'\n        }\n    ]\n    */\n    public loadFromData(data: NodeData[]): Node {\n        this.removeChildren();\n\n        for (const o of data) {\n            const node = this.createNode(o);\n            this.addChild(node);\n\n            if (\n                typeof o === \"object\" &&\n                o[\"children\"] &&\n                o[\"children\"] instanceof Array\n            ) {\n                if (o[\"children\"].length === 0) {\n                    node.isEmptyFolder = true;\n                } else {\n                    node.loadFromData(o[\"children\"]);\n                }\n            }\n        }\n\n        return this;\n    }\n\n    /*\n    Add child.\n\n    tree.addChild(\n        new Node('child1')\n    );\n    */\n    public addChild(node: Node): void {\n        this.children.push(node);\n        node.setParent(this);\n    }\n\n    /*\n    Add child at position. Index starts at 0.\n\n    tree.addChildAtPosition(\n        new Node('abc'),\n        1\n    );\n    */\n    public addChildAtPosition(node: Node, index: number): void {\n        this.children.splice(index, 0, node);\n        node.setParent(this);\n    }\n\n    /*\n    Remove child. This also removes the children of the node.\n\n    tree.removeChild(tree.children[0]);\n    */\n    public removeChild(node: Node): void {\n        // remove children from the index\n        node.removeChildren();\n\n        this.doRemoveChild(node);\n    }\n\n    /*\n    Get child index.\n\n    var index = getChildIndex(node);\n    */\n    public getChildIndex(node: Node): number {\n        return this.children.indexOf(node);\n    }\n\n    /*\n    Does the tree have children?\n\n    if (tree.hasChildren()) {\n        //\n    }\n    */\n    public hasChildren(): boolean {\n        return this.children.length !== 0;\n    }\n\n    public isFolder(): boolean {\n        return this.hasChildren() || this.load_on_demand;\n    }\n\n    /*\n    Iterate over all the nodes in the tree.\n\n    Calls callback with (node, level).\n\n    The callback must return true to continue the iteration on current node.\n\n    tree.iterate(\n        function(node, level) {\n           console.log(node.name);\n\n           // stop iteration after level 2\n           return (level <= 2);\n        }\n    );\n\n    */\n    public iterate(callback: IterateCallback): void {\n        const _iterate = (node: Node, level: number): void => {\n            if (node.children) {\n                for (const child of node.children) {\n                    const result = callback(child, level);\n\n                    if (result && child.hasChildren()) {\n                        _iterate(child, level + 1);\n                    }\n                }\n            }\n        };\n\n        _iterate(this, 0);\n    }\n\n    /*\n    Move node relative to another node.\n\n    Argument position: Position.BEFORE, Position.AFTER or Position.Inside\n\n    // move node1 after node2\n    tree.moveNode(node1, node2, Position.AFTER);\n    */\n    public moveNode(\n        movedNode: Node,\n        targetNode: Node,\n        position: Position\n    ): boolean {\n        if (!movedNode.parent || movedNode.isParentOf(targetNode)) {\n            // - Node is parent of target node\n            // - Or, parent is empty\n            return false;\n        } else {\n            movedNode.parent.doRemoveChild(movedNode);\n\n            switch (position) {\n                case Position.After: {\n                    if (targetNode.parent) {\n                        targetNode.parent.addChildAtPosition(\n                            movedNode,\n                            targetNode.parent.getChildIndex(targetNode) + 1\n                        );\n                        return true;\n                    }\n                    return false;\n                }\n\n                case Position.Before: {\n                    if (targetNode.parent) {\n                        targetNode.parent.addChildAtPosition(\n                            movedNode,\n                            targetNode.parent.getChildIndex(targetNode)\n                        );\n                        return true;\n                    }\n                    return false;\n                }\n\n                case Position.Inside: {\n                    // move inside as first child\n                    targetNode.addChildAtPosition(movedNode, 0);\n                    return true;\n                }\n\n                default:\n                    return false;\n            }\n        }\n    }\n\n    /*\n    Get the tree as data.\n    */\n    public getData(includeParent = false): DefaultRecord[] {\n        const getDataFromNodes = (nodes: Node[]): Record<string, unknown>[] => {\n            return nodes.map((node) => {\n                const tmpNode: Record<string, unknown> = {};\n\n                for (const k in node) {\n                    if (\n                        [\n                            \"parent\",\n                            \"children\",\n                            \"element\",\n                            \"idMapping\",\n                            \"load_on_demand\",\n                            \"nodeClass\",\n                            \"tree\",\n                            \"isEmptyFolder\",\n                        ].indexOf(k) === -1 &&\n                        Object.prototype.hasOwnProperty.call(node, k)\n                    ) {\n                        const v = node[k];\n                        tmpNode[k] = v;\n                    }\n                }\n\n                if (node.hasChildren()) {\n                    tmpNode[\"children\"] = getDataFromNodes(node.children);\n                }\n\n                return tmpNode;\n            });\n        };\n\n        if (includeParent) {\n            return getDataFromNodes([this]);\n        } else {\n            return getDataFromNodes(this.children);\n        }\n    }\n\n    public getNodeByName(name: string): Node | null {\n        return this.getNodeByCallback((node: Node) => node.name === name);\n    }\n\n    public getNodeByNameMustExist(name: string): Node {\n        const node = this.getNodeByCallback((n: Node) => n.name === name);\n\n        if (!node) {\n            throw `Node with name ${name} not found`;\n        }\n\n        return node;\n    }\n\n    public getNodeByCallback(callback: (node: Node) => boolean): Node | null {\n        let result: Node | null = null;\n\n        this.iterate((node: Node) => {\n            if (result) {\n                return false;\n            } else if (callback(node)) {\n                result = node;\n                return false;\n            } else {\n                return true;\n            }\n        });\n\n        return result;\n    }\n\n    public addAfter(nodeInfo: NodeData): Node | null {\n        if (!this.parent) {\n            return null;\n        } else {\n            const node = this.createNode(nodeInfo);\n\n            const childIndex = this.parent.getChildIndex(this);\n            this.parent.addChildAtPosition(node, childIndex + 1);\n\n            if (\n                typeof nodeInfo === \"object\" &&\n                nodeInfo[\"children\"] &&\n                nodeInfo[\"children\"] instanceof Array &&\n                nodeInfo[\"children\"].length\n            ) {\n                node.loadFromData(nodeInfo[\"children\"]);\n            }\n\n            return node;\n        }\n    }\n\n    public addBefore(nodeInfo: NodeData): Node | null {\n        if (!this.parent) {\n            return null;\n        } else {\n            const node = this.createNode(nodeInfo);\n\n            const childIndex = this.parent.getChildIndex(this);\n            this.parent.addChildAtPosition(node, childIndex);\n\n            if (\n                typeof nodeInfo === \"object\" &&\n                nodeInfo[\"children\"] &&\n                nodeInfo[\"children\"] instanceof Array &&\n                nodeInfo[\"children\"].length\n            ) {\n                node.loadFromData(nodeInfo[\"children\"]);\n            }\n\n            return node;\n        }\n    }\n\n    public addParent(nodeInfo: NodeData): Node | null {\n        if (!this.parent) {\n            return null;\n        } else {\n            const newParent = this.createNode(nodeInfo);\n\n            if (this.tree) {\n                newParent.setParent(this.tree);\n            }\n            const originalParent = this.parent;\n\n            for (const child of originalParent.children) {\n                newParent.addChild(child);\n            }\n\n            originalParent.children = [];\n            originalParent.addChild(newParent);\n            return newParent;\n        }\n    }\n\n    public remove(): void {\n        if (this.parent) {\n            this.parent.removeChild(this);\n            this.parent = null;\n        }\n    }\n\n    public append(nodeInfo: NodeData): Node {\n        const node = this.createNode(nodeInfo);\n        this.addChild(node);\n\n        if (\n            typeof nodeInfo === \"object\" &&\n            nodeInfo[\"children\"] &&\n            nodeInfo[\"children\"] instanceof Array &&\n            nodeInfo[\"children\"].length\n        ) {\n            node.loadFromData(nodeInfo[\"children\"]);\n        }\n\n        return node;\n    }\n\n    public prepend(nodeInfo: NodeData): Node {\n        const node = this.createNode(nodeInfo);\n        this.addChildAtPosition(node, 0);\n\n        if (\n            typeof nodeInfo === \"object\" &&\n            nodeInfo[\"children\"] &&\n            nodeInfo[\"children\"] instanceof Array &&\n            nodeInfo[\"children\"].length\n        ) {\n            node.loadFromData(nodeInfo[\"children\"]);\n        }\n\n        return node;\n    }\n\n    public isParentOf(node: Node): boolean {\n        let parent = node.parent;\n\n        while (parent) {\n            if (parent === this) {\n                return true;\n            }\n\n            parent = parent.parent;\n        }\n\n        return false;\n    }\n\n    public getLevel(): number {\n        let level = 0;\n        let node: Node = this; // eslint-disable-line @typescript-eslint/no-this-alias\n\n        while (node.parent) {\n            level += 1;\n            node = node.parent;\n        }\n\n        return level;\n    }\n\n    public getNodeById(nodeId: NodeId): Node | null {\n        return this.idMapping[nodeId] || null;\n    }\n\n    public addNodeToIndex(node: Node): void {\n        if (node.id != null) {\n            this.idMapping[node.id] = node;\n        }\n    }\n\n    public removeNodeFromIndex(node: Node): void {\n        if (node.id != null) {\n            delete this.idMapping[node.id];\n        }\n    }\n\n    public removeChildren(): void {\n        this.iterate((child: Node) => {\n            this.tree?.removeNodeFromIndex(child);\n            return true;\n        });\n\n        this.children = [];\n    }\n\n    public getPreviousSibling(): Node | null {\n        if (!this.parent) {\n            return null;\n        } else {\n            const previousIndex = this.parent.getChildIndex(this) - 1;\n            if (previousIndex >= 0) {\n                return this.parent.children[previousIndex];\n            } else {\n                return null;\n            }\n        }\n    }\n\n    public getNextSibling(): Node | null {\n        if (!this.parent) {\n            return null;\n        } else {\n            const nextIndex = this.parent.getChildIndex(this) + 1;\n            if (nextIndex < this.parent.children.length) {\n                return this.parent.children[nextIndex];\n            } else {\n                return null;\n            }\n        }\n    }\n\n    public getNodesByProperty(key: string, value: unknown): Node[] {\n        return this.filter((node: Node) => node[key] === value);\n    }\n\n    public filter(f: (node: Node) => boolean): Node[] {\n        const result: Node[] = [];\n\n        this.iterate((node: Node) => {\n            if (f(node)) {\n                result.push(node);\n            }\n\n            return true;\n        });\n\n        return result;\n    }\n\n    public getNextNode(includeChildren = true): Node | null {\n        if (includeChildren && this.hasChildren() && this.is_open) {\n            // First child\n            return this.children[0];\n        } else {\n            if (!this.parent) {\n                return null;\n            } else {\n                const nextSibling = this.getNextSibling();\n                if (nextSibling) {\n                    // Next sibling\n                    return nextSibling;\n                } else {\n                    // Next node of parent\n                    return this.parent.getNextNode(false);\n                }\n            }\n        }\n    }\n\n    public getPreviousNode(): Node | null {\n        if (!this.parent) {\n            return null;\n        } else {\n            const previousSibling = this.getPreviousSibling();\n            if (previousSibling) {\n                if (\n                    !previousSibling.hasChildren() ||\n                    !previousSibling.is_open\n                ) {\n                    // Previous sibling\n                    return previousSibling;\n                } else {\n                    // Last child of previous sibling\n                    return previousSibling.getLastChild();\n                }\n            } else {\n                return this.getParent();\n            }\n        }\n    }\n\n    public getParent(): Node | null {\n        // Return parent except if it is the root node\n        if (!this.parent) {\n            return null;\n        } else if (!this.parent.parent) {\n            // Root node -> null\n            return null;\n        } else {\n            return this.parent;\n        }\n    }\n\n    public getLastChild(): Node | null {\n        if (!this.hasChildren()) {\n            return null;\n        } else {\n            const lastChild = this.children[this.children.length - 1];\n            if (!(lastChild.hasChildren() && lastChild.is_open)) {\n                return lastChild;\n            } else {\n                return lastChild.getLastChild();\n            }\n        }\n    }\n\n    // Init Node from data without making it the root of the tree\n    public initFromData(data: NodeData): void {\n        const addNode = (nodeData: NodeData): void => {\n            this.setData(nodeData);\n\n            if (\n                typeof nodeData === \"object\" &&\n                nodeData[\"children\"] &&\n                nodeData[\"children\"] instanceof Array &&\n                nodeData[\"children\"].length\n            ) {\n                addChildren(nodeData[\"children\"]);\n            }\n        };\n\n        const addChildren = (childrenData: NodeData[]): void => {\n            for (const child of childrenData) {\n                const node = this.createNode();\n                node.initFromData(child);\n                this.addChild(node);\n            }\n        };\n\n        addNode(data);\n    }\n\n    private setParent(parent: Node): void {\n        this.parent = parent;\n        this.tree = parent.tree;\n        this.tree?.addNodeToIndex(this);\n    }\n\n    private doRemoveChild(node: Node): void {\n        this.children.splice(this.getChildIndex(node), 1);\n        this.tree?.removeNodeFromIndex(node);\n    }\n\n    private getNodeClass(): typeof Node {\n        return this.nodeClass || this?.tree?.nodeClass || Node;\n    }\n\n    private createNode(nodeData?: NodeData): Node {\n        const nodeClass = this.getNodeClass();\n        return new nodeClass(nodeData);\n    }\n}\n","import * as jQueryProxy from \"jquery\";\nimport { getPositionName, Node, Position } from \"./node\";\nimport { DropHint, HitArea, PositionInfo } from \"./types\";\nimport { NodeElement } from \"./nodeElement\";\nimport { JqTreeWidget } from \"./tree.jquery\";\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\nconst jQuery: JQueryStatic = (<any>jQueryProxy).default || jQueryProxy;\n\ninterface Dimensions {\n    left: number;\n    top: number;\n    right: number;\n    bottom: number;\n}\n\nexport class DragAndDropHandler {\n    public hitAreas: HitArea[];\n    public isDragging: boolean;\n    public currentItem: NodeElement | null;\n    public hoveredArea: HitArea | null;\n    public positionInfo: PositionInfo | null;\n\n    private treeWidget: JqTreeWidget;\n    private dragElement: DragElement | null;\n    private previousGhost: DropHint | null;\n    private openFolderTimer: number | null;\n\n    constructor(treeWidget: JqTreeWidget) {\n        this.treeWidget = treeWidget;\n\n        this.hoveredArea = null;\n        this.hitAreas = [];\n        this.isDragging = false;\n        this.currentItem = null;\n        this.positionInfo = null;\n    }\n\n    public mouseCapture(positionInfo: PositionInfo): boolean | null {\n        const $element = jQuery(positionInfo.target);\n\n        if (!this.mustCaptureElement($element)) {\n            return null;\n        }\n\n        if (\n            this.treeWidget.options.onIsMoveHandle &&\n            !this.treeWidget.options.onIsMoveHandle($element)\n        ) {\n            return null;\n        }\n\n        let nodeElement = this.treeWidget._getNodeElement($element);\n\n        if (nodeElement && this.treeWidget.options.onCanMove) {\n            if (!this.treeWidget.options.onCanMove(nodeElement.node)) {\n                nodeElement = null;\n            }\n        }\n\n        this.currentItem = nodeElement;\n        return this.currentItem != null;\n    }\n\n    public mouseStart(positionInfo: PositionInfo): boolean {\n        if (\n            !this.currentItem ||\n            positionInfo.pageX === undefined ||\n            positionInfo.pageY === undefined\n        ) {\n            return false;\n        }\n\n        this.refresh();\n\n        const offset = jQuery(positionInfo.target).offset();\n        const left = offset ? offset.left : 0;\n        const top = offset ? offset.top : 0;\n\n        const node = this.currentItem.node;\n\n        this.dragElement = new DragElement(\n            node.name,\n            positionInfo.pageX - left,\n            positionInfo.pageY - top,\n            this.treeWidget.element,\n            this.treeWidget.options.autoEscape ?? true\n        );\n\n        this.isDragging = true;\n        this.positionInfo = positionInfo;\n        this.currentItem.$element.addClass(\"jqtree-moving\");\n        return true;\n    }\n\n    public mouseDrag(positionInfo: PositionInfo): boolean {\n        if (\n            !this.currentItem ||\n            !this.dragElement ||\n            positionInfo.pageX === undefined ||\n            positionInfo.pageY === undefined\n        ) {\n            return false;\n        }\n\n        this.dragElement.move(positionInfo.pageX, positionInfo.pageY);\n        this.positionInfo = positionInfo;\n\n        const area = this.findHoveredArea(\n            positionInfo.pageX,\n            positionInfo.pageY\n        );\n\n        if (area && this.canMoveToArea(area)) {\n            if (!area.node.isFolder()) {\n                this.stopOpenFolderTimer();\n            }\n\n            if (this.hoveredArea !== area) {\n                this.hoveredArea = area;\n\n                // If this is a closed folder, start timer to open it\n                if (this.mustOpenFolderTimer(area)) {\n                    this.startOpenFolderTimer(area.node);\n                } else {\n                    this.stopOpenFolderTimer();\n                }\n\n                this.updateDropHint();\n            }\n        } else {\n            this.removeDropHint();\n            this.stopOpenFolderTimer();\n            this.hoveredArea = area;\n        }\n\n        if (!area) {\n            if (this.treeWidget.options.onDragMove) {\n                this.treeWidget.options.onDragMove(\n                    this.currentItem.node,\n                    positionInfo.originalEvent\n                );\n            }\n        }\n\n        return true;\n    }\n\n    public mouseStop(positionInfo: PositionInfo): boolean {\n        this.moveItem(positionInfo);\n        this.clear();\n        this.removeHover();\n        this.removeDropHint();\n        this.removeHitAreas();\n\n        const currentItem = this.currentItem;\n\n        if (this.currentItem) {\n            this.currentItem.$element.removeClass(\"jqtree-moving\");\n            this.currentItem = null;\n        }\n\n        this.isDragging = false;\n        this.positionInfo = null;\n\n        if (!this.hoveredArea && currentItem) {\n            if (this.treeWidget.options.onDragStop) {\n                this.treeWidget.options.onDragStop(\n                    currentItem.node,\n                    positionInfo.originalEvent\n                );\n            }\n        }\n\n        return false;\n    }\n\n    public refresh(): void {\n        this.removeHitAreas();\n\n        if (this.currentItem) {\n            this.generateHitAreas();\n\n            this.currentItem = this.treeWidget._getNodeElementForNode(\n                this.currentItem.node\n            );\n\n            if (this.isDragging) {\n                this.currentItem.$element.addClass(\"jqtree-moving\");\n            }\n        }\n    }\n\n    private generateHitAreas(): void {\n        if (!this.currentItem) {\n            this.hitAreas = [];\n        } else {\n            const hitAreasGenerator = new HitAreasGenerator(\n                this.treeWidget.tree,\n                this.currentItem.node,\n                this.getTreeDimensions().bottom\n            );\n            this.hitAreas = hitAreasGenerator.generate();\n        }\n    }\n\n    private mustCaptureElement($element: JQuery<HTMLElement>): boolean {\n        return !$element.is(\"input,select,textarea\");\n    }\n\n    private canMoveToArea(area: HitArea): boolean {\n        if (!this.treeWidget.options.onCanMoveTo) {\n            return true;\n        }\n\n        if (!this.currentItem) {\n            return false;\n        }\n\n        const positionName = getPositionName(area.position);\n\n        return this.treeWidget.options.onCanMoveTo(\n            this.currentItem.node,\n            area.node,\n            positionName\n        );\n    }\n\n    private removeHitAreas(): void {\n        this.hitAreas = [];\n    }\n\n    private clear(): void {\n        if (this.dragElement) {\n            this.dragElement.remove();\n            this.dragElement = null;\n        }\n    }\n\n    private removeDropHint(): void {\n        if (this.previousGhost) {\n            this.previousGhost.remove();\n        }\n    }\n\n    private removeHover(): void {\n        this.hoveredArea = null;\n    }\n\n    private findHoveredArea(x: number, y: number): HitArea | null {\n        const dimensions = this.getTreeDimensions();\n\n        if (\n            x < dimensions.left ||\n            y < dimensions.top ||\n            x > dimensions.right ||\n            y > dimensions.bottom\n        ) {\n            return null;\n        }\n\n        let low = 0;\n        let high = this.hitAreas.length;\n        while (low < high) {\n            const mid = (low + high) >> 1;\n            const area = this.hitAreas[mid];\n\n            if (y < area.top) {\n                high = mid;\n            } else if (y > area.bottom) {\n                low = mid + 1;\n            } else {\n                return area;\n            }\n        }\n\n        return null;\n    }\n\n    private mustOpenFolderTimer(area: HitArea): boolean {\n        const node = area.node;\n\n        return (\n            node.isFolder() &&\n            !node.is_open &&\n            area.position === Position.Inside\n        );\n    }\n\n    private updateDropHint(): void {\n        if (!this.hoveredArea) {\n            return;\n        }\n\n        // remove previous drop hint\n        this.removeDropHint();\n\n        // add new drop hint\n        const nodeElement = this.treeWidget._getNodeElementForNode(\n            this.hoveredArea.node\n        );\n        this.previousGhost = nodeElement.addDropHint(this.hoveredArea.position);\n    }\n\n    private startOpenFolderTimer(folder: Node): void {\n        const openFolder = (): void => {\n            this.treeWidget._openNode(\n                folder,\n                this.treeWidget.options.slide,\n                () => {\n                    this.refresh();\n                    this.updateDropHint();\n                }\n            );\n        };\n\n        this.stopOpenFolderTimer();\n\n        this.openFolderTimer = window.setTimeout(\n            openFolder,\n            this.treeWidget.options.openFolderDelay\n        );\n    }\n\n    private stopOpenFolderTimer(): void {\n        if (this.openFolderTimer) {\n            clearTimeout(this.openFolderTimer);\n            this.openFolderTimer = null;\n        }\n    }\n\n    private moveItem(positionInfo: PositionInfo): void {\n        if (\n            this.currentItem &&\n            this.hoveredArea &&\n            this.hoveredArea.position !== Position.None &&\n            this.canMoveToArea(this.hoveredArea)\n        ) {\n            const movedNode = this.currentItem.node;\n            const targetNode = this.hoveredArea.node;\n            const position = this.hoveredArea.position;\n            const previousParent = movedNode.parent;\n\n            if (position === Position.Inside) {\n                this.hoveredArea.node.is_open = true;\n            }\n\n            const doMove = (): void => {\n                this.treeWidget.tree.moveNode(movedNode, targetNode, position);\n                this.treeWidget.element.empty();\n                this.treeWidget._refreshElements(null);\n            };\n\n            const event = this.treeWidget._triggerEvent(\"tree.move\", {\n                move_info: {\n                    moved_node: movedNode,\n                    target_node: targetNode,\n                    position: getPositionName(position),\n                    previous_parent: previousParent,\n                    do_move: doMove,\n                    original_event: positionInfo.originalEvent,\n                },\n            });\n\n            if (!event.isDefaultPrevented()) {\n                doMove();\n            }\n        }\n    }\n\n    private getTreeDimensions(): Dimensions {\n        // Return the dimensions of the tree. Add a margin to the bottom to allow\n        // to drag-and-drop after the last element.\n        const offset = this.treeWidget.element.offset();\n\n        if (!offset) {\n            return { left: 0, top: 0, right: 0, bottom: 0 };\n        } else {\n            const el = this.treeWidget.element;\n            const width = el.width() || 0;\n            const height = el.height() || 0;\n            const left = offset.left + this.treeWidget._getScrollLeft();\n\n            return {\n                left,\n                top: offset.top,\n                right: left + width,\n                bottom: offset.top + height + 16,\n            };\n        }\n    }\n}\n\nabstract class VisibleNodeIterator {\n    private tree: Node;\n\n    constructor(tree: Node) {\n        this.tree = tree;\n    }\n\n    protected iterate(): void {\n        let isFirstNode = true;\n\n        const _iterateNode = (node: Node, nextNode: Node | null): void => {\n            let mustIterateInside =\n                (node.is_open || !node.element) && node.hasChildren();\n\n            let $element: JQuery<HTMLElement> | null = null;\n\n            if (node.element) {\n                $element = jQuery(node.element);\n\n                if (!$element.is(\":visible\")) {\n                    return;\n                }\n\n                if (isFirstNode) {\n                    this.handleFirstNode(node);\n                    isFirstNode = false;\n                }\n\n                if (!node.hasChildren()) {\n                    this.handleNode(node, nextNode, $element);\n                } else if (node.is_open) {\n                    if (!this.handleOpenFolder(node, $element)) {\n                        mustIterateInside = false;\n                    }\n                } else {\n                    this.handleClosedFolder(node, nextNode, $element);\n                }\n            }\n\n            if (mustIterateInside) {\n                const childrenLength = node.children.length;\n                node.children.forEach((_, i) => {\n                    if (i === childrenLength - 1) {\n                        _iterateNode(node.children[i], null);\n                    } else {\n                        _iterateNode(node.children[i], node.children[i + 1]);\n                    }\n                });\n\n                if (node.is_open && $element) {\n                    this.handleAfterOpenFolder(node, nextNode);\n                }\n            }\n        };\n\n        _iterateNode(this.tree, null);\n    }\n\n    protected abstract handleNode(\n        node: Node,\n        nextNode: Node | null,\n        $element: JQuery\n    ): void;\n\n    /*\n    override\n    return\n        - true: continue iterating\n        - false: stop iterating\n    */\n    protected abstract handleOpenFolder(node: Node, $element: JQuery): boolean;\n\n    protected abstract handleClosedFolder(\n        node: Node,\n        nextNode: Node | null,\n        $element: JQuery\n    ): void;\n\n    protected abstract handleAfterOpenFolder(\n        node: Node,\n        nextNode: Node | null\n    ): void;\n\n    protected abstract handleFirstNode(node: Node): void;\n}\n\nexport class HitAreasGenerator extends VisibleNodeIterator {\n    private currentNode: Node;\n    private treeBottom: number;\n    private positions: HitArea[];\n    private lastTop: number;\n\n    constructor(tree: Node, currentNode: Node, treeBottom: number) {\n        super(tree);\n\n        this.currentNode = currentNode;\n        this.treeBottom = treeBottom;\n    }\n\n    public generate(): HitArea[] {\n        this.positions = [];\n        this.lastTop = 0;\n\n        this.iterate();\n\n        return this.generateHitAreas(this.positions);\n    }\n\n    protected generateHitAreas(positions: HitArea[]): HitArea[] {\n        let previousTop = -1;\n        let group = [];\n        const hitAreas: HitArea[] = [];\n\n        for (const position of positions) {\n            if (position.top !== previousTop && group.length) {\n                if (group.length) {\n                    this.generateHitAreasForGroup(\n                        hitAreas,\n                        group,\n                        previousTop,\n                        position.top\n                    );\n                }\n\n                previousTop = position.top;\n                group = [];\n            }\n\n            group.push(position);\n        }\n\n        this.generateHitAreasForGroup(\n            hitAreas,\n            group,\n            previousTop,\n            this.treeBottom\n        );\n\n        return hitAreas;\n    }\n\n    protected handleOpenFolder(node: Node, $element: JQuery): boolean {\n        if (node === this.currentNode) {\n            // Cannot move inside current item\n            // Stop iterating\n            return false;\n        }\n\n        // Cannot move before current item\n        if (node.children[0] !== this.currentNode) {\n            this.addPosition(node, Position.Inside, this.getTop($element));\n        }\n\n        // Continue iterating\n        return true;\n    }\n\n    protected handleClosedFolder(\n        node: Node,\n        nextNode: Node,\n        $element: JQuery\n    ): void {\n        const top = this.getTop($element);\n\n        if (node === this.currentNode) {\n            // Cannot move after current item\n            this.addPosition(node, Position.None, top);\n        } else {\n            this.addPosition(node, Position.Inside, top);\n\n            // Cannot move before current item\n            if (nextNode !== this.currentNode) {\n                this.addPosition(node, Position.After, top);\n            }\n        }\n    }\n\n    protected handleFirstNode(node: Node): void {\n        if (node !== this.currentNode) {\n            this.addPosition(\n                node,\n                Position.Before,\n                this.getTop(jQuery(node.element))\n            );\n        }\n    }\n\n    protected handleAfterOpenFolder(node: Node, nextNode: Node): void {\n        if (node === this.currentNode || nextNode === this.currentNode) {\n            // Cannot move before or after current item\n            this.addPosition(node, Position.None, this.lastTop);\n        } else {\n            this.addPosition(node, Position.After, this.lastTop);\n        }\n    }\n\n    protected handleNode(node: Node, nextNode: Node, $element: JQuery): void {\n        const top = this.getTop($element);\n\n        if (node === this.currentNode) {\n            // Cannot move inside current item\n            this.addPosition(node, Position.None, top);\n        } else {\n            this.addPosition(node, Position.Inside, top);\n        }\n\n        if (nextNode === this.currentNode || node === this.currentNode) {\n            // Cannot move before or after current item\n            this.addPosition(node, Position.None, top);\n        } else {\n            this.addPosition(node, Position.After, top);\n        }\n    }\n\n    private getTop($element: JQuery<HTMLElement>): number {\n        const offset = $element.offset();\n\n        return offset ? offset.top : 0;\n    }\n\n    private addPosition(node: Node, position: number, top: number): void {\n        const area = {\n            top,\n            bottom: 0,\n            node,\n            position,\n        };\n\n        this.positions.push(area);\n        this.lastTop = top;\n    }\n\n    private generateHitAreasForGroup(\n        hitAreas: HitArea[],\n        positionsInGroup: HitArea[],\n        top: number,\n        bottom: number\n    ): void {\n        // limit positions in group\n        const positionCount = Math.min(positionsInGroup.length, 4);\n\n        const areaHeight = Math.round((bottom - top) / positionCount);\n        let areaTop = top;\n\n        let i = 0;\n        while (i < positionCount) {\n            const position = positionsInGroup[i];\n\n            hitAreas.push({\n                top: areaTop,\n                bottom: areaTop + areaHeight,\n                node: position.node,\n                position: position.position,\n            });\n\n            areaTop += areaHeight;\n            i += 1;\n        }\n    }\n}\n\nclass DragElement {\n    private offsetX: number;\n    private offsetY: number;\n    private $element: JQuery;\n\n    constructor(\n        nodeName: string,\n        offsetX: number,\n        offsetY: number,\n        $tree: JQuery,\n        autoEscape: boolean\n    ) {\n        this.offsetX = offsetX;\n        this.offsetY = offsetY;\n\n        this.$element = jQuery(\"<span>\").addClass(\n            \"jqtree-title jqtree-dragging\"\n        );\n\n        if (autoEscape) {\n            this.$element.text(nodeName);\n        } else {\n            this.$element.html(nodeName);\n        }\n\n        this.$element.css(\"position\", \"absolute\");\n        $tree.append(this.$element);\n    }\n\n    public move(pageX: number, pageY: number): void {\n        this.$element.offset({\n            left: pageX - this.offsetX,\n            top: pageY - this.offsetY,\n        });\n    }\n\n    public remove(): void {\n        this.$element.remove();\n    }\n}\n","export const isInt = (n: unknown): boolean =>\n    typeof n === \"number\" && n % 1 === 0;\n\nexport const isFunction = (v: unknown): boolean => typeof v === \"function\";\n\nexport const getBoolString = (value: unknown): string =>\n    value ? \"true\" : \"false\";\n","import { getBoolString } from \"./util\";\nimport { Node } from \"./node\";\nimport { JqTreeWidget } from \"./tree.jquery\";\n\ntype IconElement = Text | Element;\n\nexport default class ElementsRenderer {\n    public openedIconElement: IconElement;\n    public closedIconElement: IconElement;\n    private treeWidget: JqTreeWidget;\n\n    constructor(treeWidget: JqTreeWidget) {\n        this.treeWidget = treeWidget;\n\n        this.openedIconElement = this.createButtonElement(\n            treeWidget.options.openedIcon || \"+\"\n        );\n        this.closedIconElement = this.createButtonElement(\n            treeWidget.options.closedIcon || \"-\"\n        );\n    }\n\n    public render(fromNode: Node | null): void {\n        if (fromNode && fromNode.parent) {\n            this.renderFromNode(fromNode);\n        } else {\n            this.renderFromRoot();\n        }\n    }\n\n    public renderFromRoot(): void {\n        const $element = this.treeWidget.element;\n        $element.empty();\n\n        this.createDomElements(\n            $element[0],\n            this.treeWidget.tree.children,\n            true,\n            1\n        );\n    }\n\n    public renderFromNode(node: Node): void {\n        // remember current li\n        const $previousLi = jQuery(node.element);\n\n        // create element\n        const li = this.createLi(node, node.getLevel());\n        this.attachNodeData(node, li);\n\n        // add element to dom\n        $previousLi.after(li);\n\n        // remove previous li\n        $previousLi.remove();\n\n        // create children\n        if (node.children) {\n            this.createDomElements(\n                li,\n                node.children,\n                false,\n                node.getLevel() + 1\n            );\n        }\n    }\n\n    private createDomElements(\n        element: Element,\n        children: Node[],\n        isRootNode: boolean,\n        level: number\n    ): void {\n        const ul = this.createUl(isRootNode);\n        element.appendChild(ul);\n\n        for (const child of children) {\n            const li = this.createLi(child, level);\n            ul.appendChild(li);\n\n            this.attachNodeData(child, li);\n\n            if (child.hasChildren()) {\n                this.createDomElements(li, child.children, false, level + 1);\n            }\n        }\n    }\n\n    private attachNodeData(node: Node, li: HTMLElement): void {\n        node.element = li;\n        jQuery(li).data(\"node\", node);\n    }\n\n    private createUl(isRootNode: boolean): HTMLUListElement {\n        let classString;\n        let role;\n\n        if (!isRootNode) {\n            classString = \"\";\n            role = \"group\";\n        } else {\n            classString = \"jqtree-tree\";\n            role = \"tree\";\n\n            if (this.treeWidget.options.rtl) {\n                classString += \" jqtree-rtl\";\n            }\n        }\n\n        if (this.treeWidget.options.dragAndDrop) {\n            classString += \" jqtree-dnd\";\n        }\n\n        const ul = document.createElement(\"ul\");\n        ul.className = `jqtree_common ${classString}`;\n\n        ul.setAttribute(\"role\", role);\n\n        return ul;\n    }\n\n    private createLi(node: Node, level: number): HTMLLIElement {\n        const isSelected = Boolean(\n            this.treeWidget.selectNodeHandler.isNodeSelected(node)\n        );\n\n        const mustShowFolder =\n            node.isFolder() ||\n            (node.isEmptyFolder && this.treeWidget.options.showEmptyFolder);\n\n        const li = mustShowFolder\n            ? this.createFolderLi(node, level, isSelected)\n            : this.createNodeLi(node, level, isSelected);\n\n        if (this.treeWidget.options.onCreateLi) {\n            this.treeWidget.options.onCreateLi(node, jQuery(li), isSelected);\n        }\n\n        return li;\n    }\n\n    private createFolderLi(\n        node: Node,\n        level: number,\n        isSelected: boolean\n    ): HTMLLIElement {\n        const buttonClasses = this.getButtonClasses(node);\n        const folderClasses = this.getFolderClasses(node, isSelected);\n\n        const iconElement = node.is_open\n            ? this.openedIconElement\n            : this.closedIconElement;\n\n        // li\n        const li = document.createElement(\"li\");\n        li.className = `jqtree_common ${folderClasses}`;\n        li.setAttribute(\"role\", \"presentation\");\n\n        // div\n        const div = document.createElement(\"div\");\n        div.className = \"jqtree-element jqtree_common\";\n        div.setAttribute(\"role\", \"presentation\");\n\n        li.appendChild(div);\n\n        // button link\n        const buttonLink = document.createElement(\"a\");\n        buttonLink.className = buttonClasses;\n\n        buttonLink.appendChild(iconElement.cloneNode(true));\n\n        buttonLink.setAttribute(\"role\", \"presentation\");\n        buttonLink.setAttribute(\"aria-hidden\", \"true\");\n\n        if (this.treeWidget.options.buttonLeft) {\n            div.appendChild(buttonLink);\n        }\n\n        // title span\n        div.appendChild(\n            this.createTitleSpan(\n                node.name,\n                level,\n                isSelected,\n                node.is_open,\n                true\n            )\n        );\n\n        if (!this.treeWidget.options.buttonLeft) {\n            div.appendChild(buttonLink);\n        }\n\n        return li;\n    }\n\n    private createNodeLi(\n        node: Node,\n        level: number,\n        isSelected: boolean\n    ): HTMLLIElement {\n        const liClasses = [\"jqtree_common\"];\n\n        if (isSelected) {\n            liClasses.push(\"jqtree-selected\");\n        }\n\n        const classString = liClasses.join(\" \");\n\n        // li\n        const li = document.createElement(\"li\");\n        li.className = classString;\n        li.setAttribute(\"role\", \"presentation\");\n\n        // div\n        const div = document.createElement(\"div\");\n        div.className = \"jqtree-element jqtree_common\";\n        div.setAttribute(\"role\", \"presentation\");\n\n        li.appendChild(div);\n\n        // title span\n        div.appendChild(\n            this.createTitleSpan(\n                node.name,\n                level,\n                isSelected,\n                node.is_open,\n                false\n            )\n        );\n\n        return li;\n    }\n\n    private createTitleSpan(\n        nodeName: string,\n        level: number,\n        isSelected: boolean,\n        isOpen: boolean,\n        isFolder: boolean\n    ): HTMLSpanElement {\n        const titleSpan = document.createElement(\"span\");\n\n        let classes = \"jqtree-title jqtree_common\";\n\n        if (isFolder) {\n            classes += \" jqtree-title-folder\";\n        }\n\n        titleSpan.className = classes;\n\n        titleSpan.setAttribute(\"role\", \"treeitem\");\n        titleSpan.setAttribute(\"aria-level\", `${level}`);\n\n        titleSpan.setAttribute(\"aria-selected\", getBoolString(isSelected));\n        titleSpan.setAttribute(\"aria-expanded\", getBoolString(isOpen));\n\n        if (isSelected) {\n            const tabIndex = this.treeWidget.options.tabIndex;\n\n            if (tabIndex !== undefined) {\n                titleSpan.setAttribute(\"tabindex\", `${tabIndex}`);\n            }\n        }\n\n        if (this.treeWidget.options.autoEscape) {\n            titleSpan.textContent = nodeName;\n        } else {\n            titleSpan.innerHTML = nodeName;\n        }\n\n        return titleSpan;\n    }\n\n    private getButtonClasses(node: Node): string {\n        const classes = [\"jqtree-toggler\", \"jqtree_common\"];\n\n        if (!node.is_open) {\n            classes.push(\"jqtree-closed\");\n        }\n\n        if (this.treeWidget.options.buttonLeft) {\n            classes.push(\"jqtree-toggler-left\");\n        } else {\n            classes.push(\"jqtree-toggler-right\");\n        }\n\n        return classes.join(\" \");\n    }\n\n    private getFolderClasses(node: Node, isSelected: boolean): string {\n        const classes = [\"jqtree-folder\"];\n\n        if (!node.is_open) {\n            classes.push(\"jqtree-closed\");\n        }\n\n        if (isSelected) {\n            classes.push(\"jqtree-selected\");\n        }\n\n        if (node.is_loading) {\n            classes.push(\"jqtree-loading\");\n        }\n\n        return classes.join(\" \");\n    }\n\n    private createButtonElement(value: string | Element): IconElement {\n        if (typeof value === \"string\") {\n            // convert value to html\n            const div = document.createElement(\"div\");\n            div.innerHTML = value;\n\n            return document.createTextNode(div.innerHTML);\n        } else {\n            return jQuery(value)[0];\n        }\n    }\n}\n","import { DefaultRecord, Node, NodeData } from \"./node\";\nimport { JqTreeWidget } from \"./tree.jquery\";\n\nexport type HandleFinishedLoading = () => void;\n\nexport default class DataLoader {\n    private treeWidget: JqTreeWidget;\n\n    constructor(treeWidget: JqTreeWidget) {\n        this.treeWidget = treeWidget;\n    }\n\n    public loadFromUrl(\n        urlInfo: string | JQuery.AjaxSettings | null,\n        parentNode: Node | null,\n        onFinished: HandleFinishedLoading | null\n    ): void {\n        if (!urlInfo) {\n            return;\n        }\n\n        const $el = this.getDomElement(parentNode);\n        this.addLoadingClass($el);\n        this.notifyLoading(true, parentNode, $el);\n\n        const stopLoading = (): void => {\n            this.removeLoadingClass($el);\n            this.notifyLoading(false, parentNode, $el);\n        };\n\n        const handleSuccess = (data: any): void => {\n            stopLoading();\n            this.treeWidget.loadData(this.parseData(data), parentNode);\n\n            if (onFinished && typeof onFinished === \"function\") {\n                onFinished();\n            }\n        };\n\n        const handleError = (jqXHR: JQuery.jqXHR): void => {\n            stopLoading();\n\n            if (this.treeWidget.options.onLoadFailed) {\n                this.treeWidget.options.onLoadFailed(jqXHR);\n            }\n        };\n\n        this.submitRequest(urlInfo, handleSuccess, handleError);\n    }\n\n    private addLoadingClass($el: JQuery<HTMLElement>): void {\n        if ($el) {\n            $el.addClass(\"jqtree-loading\");\n        }\n    }\n\n    private removeLoadingClass($el: JQuery<HTMLElement>): void {\n        if ($el) {\n            $el.removeClass(\"jqtree-loading\");\n        }\n    }\n\n    private getDomElement(parentNode: Node | null): JQuery<HTMLElement> {\n        if (parentNode) {\n            return jQuery(parentNode.element);\n        } else {\n            return this.treeWidget.element;\n        }\n    }\n\n    private notifyLoading(\n        isLoading: boolean,\n        node: Node | null,\n        $el: JQuery\n    ): void {\n        if (this.treeWidget.options.onLoading) {\n            this.treeWidget.options.onLoading(isLoading, node, $el);\n        }\n\n        this.treeWidget._triggerEvent(\"tree.loading_data\", {\n            isLoading,\n            node,\n            $el,\n        });\n    }\n\n    private submitRequest(\n        urlInfoInput: string | JQuery.AjaxSettings,\n        handleSuccess: JQuery.Ajax.SuccessCallback<any>,\n        handleError: JQuery.Ajax.ErrorCallback<any>\n    ): void {\n        const urlInfo =\n            typeof urlInfoInput === \"string\"\n                ? { url: urlInfoInput }\n                : urlInfoInput;\n\n        const ajaxSettings: JQuery.AjaxSettings = {\n            method: \"GET\",\n            cache: false,\n            dataType: \"json\",\n            success: handleSuccess,\n            error: handleError,\n            ...urlInfo,\n        };\n\n        ajaxSettings.method = ajaxSettings.method?.toUpperCase() || \"GET\";\n\n        void jQuery.ajax(ajaxSettings);\n    }\n\n    private parseData(data: NodeData): NodeData[] {\n        const { dataFilter } = this.treeWidget.options;\n\n        const getParsedData = (): unknown => {\n            if (typeof data === \"string\") {\n                return JSON.parse(data) as unknown;\n            } else {\n                return data;\n            }\n        };\n\n        const parsedData = getParsedData();\n\n        if (dataFilter) {\n            return dataFilter(parsedData);\n        } else {\n            return parsedData as DefaultRecord[];\n        }\n    }\n}\n","import { Node } from \"./node\";\nimport { JqTreeWidget } from \"./tree.jquery\";\n\nexport default class KeyHandler {\n    private static LEFT = 37;\n    private static UP = 38;\n    private static RIGHT = 39;\n    private static DOWN = 40;\n\n    private treeWidget: JqTreeWidget;\n\n    constructor(treeWidget: JqTreeWidget) {\n        this.treeWidget = treeWidget;\n\n        if (treeWidget.options.keyboardSupport) {\n            jQuery(document).on(\"keydown.jqtree\", this.handleKeyDown);\n        }\n    }\n\n    public deinit(): void {\n        jQuery(document).off(\"keydown.jqtree\");\n    }\n\n    public moveDown(selectedNode: Node): boolean {\n        return this.selectNode(selectedNode.getNextNode());\n    }\n\n    public moveUp(selectedNode: Node): boolean {\n        return this.selectNode(selectedNode.getPreviousNode());\n    }\n\n    public moveRight(selectedNode: Node): boolean {\n        if (!selectedNode.isFolder()) {\n            return true;\n        } else {\n            // folder node\n            if (selectedNode.is_open) {\n                // Right moves to the first child of an open node\n                return this.selectNode(selectedNode.getNextNode());\n            } else {\n                // Right expands a closed node\n                this.treeWidget.openNode(selectedNode);\n                return false;\n            }\n        }\n    }\n\n    public moveLeft(selectedNode: Node): boolean {\n        if (selectedNode.isFolder() && selectedNode.is_open) {\n            // Left on an open node closes the node\n            this.treeWidget.closeNode(selectedNode);\n            return false;\n        } else {\n            // Left on a closed or end node moves focus to the node's parent\n            return this.selectNode(selectedNode.getParent());\n        }\n    }\n\n    public selectNode(node: Node | null): boolean {\n        if (!node) {\n            return true;\n        } else {\n            this.treeWidget.selectNode(node);\n\n            if (\n                !this.treeWidget.scrollHandler.isScrolledIntoView(\n                    jQuery(node.element).find(\".jqtree-element\")\n                )\n            ) {\n                this.treeWidget.scrollToNode(node);\n            }\n\n            return false;\n        }\n    }\n\n    private handleKeyDown = (e: JQuery.Event): boolean => {\n        if (!this.canHandleKeyboard()) {\n            return true;\n        }\n\n        const selectedNode = this.treeWidget.getSelectedNode();\n        if (!selectedNode) {\n            return true;\n        }\n\n        const key = e.which;\n\n        switch (key) {\n            case KeyHandler.DOWN:\n                return this.moveDown(selectedNode);\n\n            case KeyHandler.UP:\n                return this.moveUp(selectedNode);\n\n            case KeyHandler.RIGHT:\n                return this.moveRight(selectedNode);\n\n            case KeyHandler.LEFT:\n                return this.moveLeft(selectedNode);\n\n            default:\n                return true;\n        }\n    };\n\n    private canHandleKeyboard(): boolean {\n        return (\n            (this.treeWidget.options.keyboardSupport || false) &&\n            this.treeWidget.selectNodeHandler.isFocusOnTree()\n        );\n    }\n}\n","const register = (widgetClass: unknown, widgetName: string): void => {\n    const getDataKey = (): string => `simple_widget_${widgetName}`;\n\n    const getWidgetData = (\n        el: HTMLElement,\n        dataKey: string\n    ): SimpleWidget<unknown> | null => {\n        const widget = jQuery.data(el, dataKey) as unknown;\n\n        if (widget && widget instanceof SimpleWidget) {\n            return widget;\n        } else {\n            return null;\n        }\n    };\n\n    const createWidget = ($el: JQuery, options: unknown): JQuery => {\n        const dataKey = getDataKey();\n\n        for (const el of $el.get()) {\n            const existingWidget = getWidgetData(el, dataKey);\n\n            if (!existingWidget) {\n                const simpleWidgetClass = widgetClass as typeof SimpleWidget;\n                const widget = new simpleWidgetClass(el, options);\n\n                if (!jQuery.data(el, dataKey)) {\n                    jQuery.data(el, dataKey, widget);\n                }\n\n                // Call init after setting data, so we can call methods\n                widget.init();\n            }\n        }\n\n        return $el;\n    };\n\n    const destroyWidget = ($el: JQuery): void => {\n        const dataKey = getDataKey();\n\n        for (const el of $el.get()) {\n            const widget = getWidgetData(el, dataKey);\n\n            if (widget) {\n                widget.destroy();\n            }\n\n            jQuery.removeData(el, dataKey);\n        }\n    };\n\n    const callFunction = (\n        $el: JQuery,\n        functionName: string,\n        args: unknown[]\n    ): unknown => {\n        let result = null;\n\n        for (const el of $el.get()) {\n            const widget = jQuery.data(el, getDataKey()) as unknown;\n\n            if (widget && widget instanceof SimpleWidget) {\n                const simpleWidget = widget as SimpleWidget<unknown>;\n                const widgetFunction = simpleWidget[functionName];\n\n                if (widgetFunction && typeof widgetFunction === \"function\") {\n                    result = widgetFunction.apply(widget, args) as unknown;\n                }\n            }\n        }\n\n        return result;\n    };\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    (jQuery.fn as any)[widgetName] = function (\n        this: JQuery,\n        argument1: unknown,\n        ...args: unknown[]\n    ) {\n        if (!argument1) {\n            return createWidget(this, null);\n        } else if (typeof argument1 === \"object\") {\n            const options = argument1 as unknown;\n            return createWidget(this, options);\n        } else if (typeof argument1 === \"string\" && argument1[0] !== \"_\") {\n            const functionName = argument1;\n\n            if (functionName === \"destroy\") {\n                return destroyWidget(this);\n            } else if (functionName === \"get_widget_class\") {\n                return widgetClass;\n            } else {\n                return callFunction(this, functionName, args);\n            }\n        }\n    };\n};\n\nexport default class SimpleWidget<WidgetOptions> {\n    public static register(widgetClass: unknown, widgetName: string): void {\n        register(widgetClass, widgetName);\n    }\n\n    [key: string]: unknown;\n\n    protected static defaults: unknown = {};\n\n    public options: WidgetOptions;\n\n    protected $el: JQuery<HTMLElement>;\n\n    constructor(el: HTMLElement, options: WidgetOptions) {\n        this.$el = jQuery(el);\n\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        const defaults = (this.constructor as any)[\"defaults\"] as WidgetOptions;\n        this.options = { ...defaults, ...options };\n    }\n\n    public destroy(): void {\n        this.deinit();\n    }\n\n    public init(): void {\n        //\n    }\n\n    public deinit(): void {\n        //\n    }\n}\n","/*\nThis widget does the same a the mouse widget in jqueryui.\n*/\nimport SimpleWidget from \"./simple.widget\";\nimport { PositionInfo } from \"./types\";\n\nconst getPositionInfoFromMouseEvent = (e: MouseEvent): PositionInfo => ({\n    pageX: e.pageX,\n    pageY: e.pageY,\n    target: e.target as HTMLElement,\n    originalEvent: e,\n});\n\nconst getPositionInfoFromTouch = (\n    touch: Touch,\n    e: TouchEvent\n): PositionInfo => ({\n    pageX: touch.pageX,\n    pageY: touch.pageY,\n    target: touch.target as HTMLElement,\n    originalEvent: e,\n});\n\nabstract class MouseWidget<WidgetOptions> extends SimpleWidget<WidgetOptions> {\n    public $el: JQuery<HTMLElement>;\n    protected isMouseStarted: boolean;\n    protected mouseDownInfo: PositionInfo | null;\n    private mouseDelayTimer: number | null;\n    private isMouseDelayMet: boolean;\n\n    public init(): void {\n        const element = this.$el.get(0);\n        element.addEventListener(\"mousedown\", this.mouseDown, {\n            passive: false,\n        });\n        element.addEventListener(\"touchstart\", this.touchStart, {\n            passive: false,\n        });\n\n        this.isMouseStarted = false;\n        this.mouseDelayTimer = null;\n        this.isMouseDelayMet = false;\n        this.mouseDownInfo = null;\n    }\n\n    public deinit(): void {\n        const el = this.$el.get(0);\n        el.removeEventListener(\"mousedown\", this.mouseDown);\n        el.removeEventListener(\"touchstart\", this.touchStart);\n\n        document.removeEventListener(\"mousemove\", this.mouseMove);\n        document.removeEventListener(\"touchmove\", this.touchMove);\n        document.removeEventListener(\"mouseup\", this.mouseUp);\n        document.removeEventListener(\"touchend\", this.touchEnd);\n    }\n\n    protected abstract mouseCapture(positionInfo: PositionInfo): boolean | null;\n\n    protected abstract mouseStart(positionInfo: PositionInfo): boolean;\n\n    protected abstract mouseDrag(positionInfo: PositionInfo): void;\n\n    protected abstract mouseStop(positionInfo: PositionInfo): void;\n\n    protected abstract getMouseDelay(): number;\n\n    private mouseDown = (e: MouseEvent): void => {\n        // Left mouse button?\n        if (e.button !== 0) {\n            return;\n        }\n\n        const result = this.handleMouseDown(getPositionInfoFromMouseEvent(e));\n\n        if (result && e.cancelable) {\n            e.preventDefault();\n        }\n    };\n\n    private handleMouseDown(positionInfo: PositionInfo): boolean {\n        // We may have missed mouseup (out of window)\n        if (this.isMouseStarted) {\n            this.handleMouseUp(positionInfo);\n        }\n\n        this.mouseDownInfo = positionInfo;\n\n        if (!this.mouseCapture(positionInfo)) {\n            return false;\n        }\n\n        this.handleStartMouse();\n\n        return true;\n    }\n\n    private handleStartMouse(): void {\n        document.addEventListener(\"mousemove\", this.mouseMove, {\n            passive: false,\n        });\n        document.addEventListener(\"touchmove\", this.touchMove, {\n            passive: false,\n        });\n        document.addEventListener(\"mouseup\", this.mouseUp, { passive: false });\n        document.addEventListener(\"touchend\", this.touchEnd, {\n            passive: false,\n        });\n\n        const mouseDelay = this.getMouseDelay();\n\n        if (mouseDelay) {\n            this.startMouseDelayTimer(mouseDelay);\n        } else {\n            this.isMouseDelayMet = true;\n        }\n    }\n\n    private startMouseDelayTimer(mouseDelay: number): void {\n        if (this.mouseDelayTimer) {\n            clearTimeout(this.mouseDelayTimer);\n        }\n\n        this.mouseDelayTimer = window.setTimeout(() => {\n            this.isMouseDelayMet = true;\n        }, mouseDelay);\n\n        this.isMouseDelayMet = false;\n    }\n\n    private mouseMove = (e: MouseEvent): void => {\n        this.handleMouseMove(e, getPositionInfoFromMouseEvent(e));\n    };\n\n    private handleMouseMove(\n        e: MouseEvent | TouchEvent,\n        positionInfo: PositionInfo\n    ): void {\n        if (this.isMouseStarted) {\n            this.mouseDrag(positionInfo);\n\n            if (e.cancelable) {\n                e.preventDefault();\n            }\n            return;\n        }\n\n        if (!this.isMouseDelayMet) {\n            return;\n        }\n\n        if (this.mouseDownInfo) {\n            this.isMouseStarted = this.mouseStart(this.mouseDownInfo) !== false;\n        }\n\n        if (this.isMouseStarted) {\n            this.mouseDrag(positionInfo);\n\n            if (e.cancelable) {\n                e.preventDefault();\n            }\n        } else {\n            this.handleMouseUp(positionInfo);\n        }\n    }\n\n    private mouseUp = (e: MouseEvent): void => {\n        this.handleMouseUp(getPositionInfoFromMouseEvent(e));\n    };\n\n    private handleMouseUp(positionInfo: PositionInfo): void {\n        document.removeEventListener(\"mousemove\", this.mouseMove);\n        document.removeEventListener(\"touchmove\", this.touchMove);\n        document.removeEventListener(\"mouseup\", this.mouseUp);\n        document.removeEventListener(\"touchend\", this.touchEnd);\n\n        if (this.isMouseStarted) {\n            this.isMouseStarted = false;\n            this.mouseStop(positionInfo);\n        }\n    }\n\n    private touchStart = (e: TouchEvent): void => {\n        if (!e) {\n            return;\n        }\n\n        if (e.touches.length > 1) {\n            return;\n        }\n\n        const touch = e.changedTouches[0];\n\n        this.handleMouseDown(getPositionInfoFromTouch(touch, e));\n    };\n\n    private touchMove = (e: TouchEvent): void => {\n        if (!e) {\n            return;\n        }\n\n        if (e.touches.length > 1) {\n            return;\n        }\n\n        const touch = e.changedTouches[0];\n\n        this.handleMouseMove(e, getPositionInfoFromTouch(touch, e));\n    };\n\n    private touchEnd = (e: TouchEvent): void => {\n        if (!e) {\n            return;\n        }\n\n        if (e.touches.length > 1) {\n            return;\n        }\n\n        const touch = e.changedTouches[0];\n\n        this.handleMouseUp(getPositionInfoFromTouch(touch, e));\n    };\n}\n\nexport default MouseWidget;\n","import { isInt } from \"./util\";\nimport { JqTreeWidget } from \"./tree.jquery\";\nimport { Node, NodeId } from \"./node\";\n\nexport default class SaveStateHandler {\n    private treeWidget: JqTreeWidget;\n    private _supportsLocalStorage: boolean | null;\n\n    constructor(treeWidget: JqTreeWidget) {\n        this.treeWidget = treeWidget;\n    }\n\n    public saveState(): void {\n        const state = JSON.stringify(this.getState());\n\n        if (this.treeWidget.options.onSetStateFromStorage) {\n            this.treeWidget.options.onSetStateFromStorage(state);\n        } else if (this.supportsLocalStorage()) {\n            localStorage.setItem(this.getKeyName(), state);\n        }\n    }\n\n    public getStateFromStorage(): SavedState | null {\n        const jsonData = this.loadFromStorage();\n\n        if (jsonData) {\n            return (this.parseState(jsonData) as unknown) as SavedState;\n        } else {\n            return null;\n        }\n    }\n\n    public getState(): SavedState {\n        const getOpenNodeIds = (): NodeId[] => {\n            const openNodes: NodeId[] = [];\n\n            this.treeWidget.tree.iterate((node: Node) => {\n                if (node.is_open && node.id && node.hasChildren()) {\n                    openNodes.push(node.id);\n                }\n                return true;\n            });\n\n            return openNodes;\n        };\n\n        const getSelectedNodeIds = (): NodeId[] => {\n            const selectedNodeIds: NodeId[] = [];\n\n            this.treeWidget.getSelectedNodes().forEach((node) => {\n                if (node.id != null) {\n                    selectedNodeIds.push(node.id);\n                }\n            });\n\n            return selectedNodeIds;\n        };\n\n        return {\n            open_nodes: getOpenNodeIds(),\n            selected_node: getSelectedNodeIds(),\n        };\n    }\n\n    /*\n    Set initial state\n    Don't handle nodes that are loaded on demand\n\n    result: must load on demand\n    */\n    public setInitialState(state: SavedState): boolean {\n        if (!state) {\n            return false;\n        } else {\n            let mustLoadOnDemand = false;\n\n            if (state.open_nodes) {\n                mustLoadOnDemand = this.openInitialNodes(state.open_nodes);\n            }\n\n            if (state.selected_node) {\n                this.resetSelection();\n                this.selectInitialNodes(state.selected_node);\n            }\n\n            return mustLoadOnDemand;\n        }\n    }\n\n    public setInitialStateOnDemand(\n        state: SavedState,\n        cbFinished: () => void\n    ): void {\n        if (state) {\n            this.doSetInitialStateOnDemand(\n                state.open_nodes,\n                state.selected_node,\n                cbFinished\n            );\n        } else {\n            cbFinished();\n        }\n    }\n\n    public getNodeIdToBeSelected(): NodeId | null {\n        const state = this.getStateFromStorage();\n\n        if (state && state.selected_node) {\n            return state.selected_node[0];\n        } else {\n            return null;\n        }\n    }\n\n    private parseState(jsonData: string): SavedState {\n        const state = JSON.parse(jsonData) as Record<string, unknown>;\n\n        // Check if selected_node is an int (instead of an array)\n        if (state && state.selected_node && isInt(state.selected_node)) {\n            // Convert to array\n            state.selected_node = [state.selected_node];\n        }\n\n        return (state as unknown) as SavedState;\n    }\n\n    private loadFromStorage(): string | null {\n        if (this.treeWidget.options.onGetStateFromStorage) {\n            return this.treeWidget.options.onGetStateFromStorage();\n        } else if (this.supportsLocalStorage()) {\n            return localStorage.getItem(this.getKeyName());\n        } else {\n            return null;\n        }\n    }\n\n    private openInitialNodes(nodeIds: any[]): boolean {\n        let mustLoadOnDemand = false;\n\n        for (const nodeDd of nodeIds) {\n            const node = this.treeWidget.getNodeById(nodeDd);\n\n            if (node) {\n                if (!node.load_on_demand) {\n                    node.is_open = true;\n                } else {\n                    mustLoadOnDemand = true;\n                }\n            }\n        }\n\n        return mustLoadOnDemand;\n    }\n\n    private selectInitialNodes(nodeIds: NodeId[]): boolean {\n        let selectCount = 0;\n\n        for (const nodeId of nodeIds) {\n            const node = this.treeWidget.getNodeById(nodeId);\n\n            if (node) {\n                selectCount += 1;\n\n                this.treeWidget.selectNodeHandler.addToSelection(node);\n            }\n        }\n\n        return selectCount !== 0;\n    }\n\n    private resetSelection(): void {\n        const selectNodeHandler = this.treeWidget.selectNodeHandler;\n\n        const selectedNodes = selectNodeHandler.getSelectedNodes();\n\n        selectedNodes.forEach((node) => {\n            selectNodeHandler.removeFromSelection(node);\n        });\n    }\n\n    private doSetInitialStateOnDemand(\n        nodeIdsParam: NodeId[],\n        selectedNodes: NodeId[],\n        cbFinished: () => void\n    ): void {\n        let loadingCount = 0;\n        let nodeIds = nodeIdsParam;\n\n        const openNodes = (): void => {\n            const newNodesIds = [];\n\n            for (const nodeId of nodeIds) {\n                const node = this.treeWidget.getNodeById(nodeId);\n\n                if (!node) {\n                    newNodesIds.push(nodeId);\n                } else {\n                    if (!node.is_loading) {\n                        if (node.load_on_demand) {\n                            loadAndOpenNode(node);\n                        } else {\n                            this.treeWidget._openNode(node, false, null);\n                        }\n                    }\n                }\n            }\n\n            nodeIds = newNodesIds;\n\n            if (this.selectInitialNodes(selectedNodes)) {\n                this.treeWidget._refreshElements(null);\n            }\n\n            if (loadingCount === 0) {\n                cbFinished();\n            }\n        };\n\n        const loadAndOpenNode = (node: Node): void => {\n            loadingCount += 1;\n            this.treeWidget._openNode(node, false, () => {\n                loadingCount -= 1;\n                openNodes();\n            });\n        };\n\n        openNodes();\n    }\n\n    private getKeyName(): string {\n        if (typeof this.treeWidget.options.saveState === \"string\") {\n            return this.treeWidget.options.saveState;\n        } else {\n            return \"tree\";\n        }\n    }\n\n    private supportsLocalStorage(): boolean {\n        const testSupport = (): boolean => {\n            // Is local storage supported?\n            if (localStorage == null) {\n                return false;\n            } else {\n                // Check if it's possible to store an item. Safari does not allow this in private browsing mode.\n                try {\n                    const key = \"_storage_test\";\n                    sessionStorage.setItem(key, \"value\");\n                    sessionStorage.removeItem(key);\n                } catch (error) {\n                    return false;\n                }\n\n                return true;\n            }\n        };\n\n        if (this._supportsLocalStorage == null) {\n            this._supportsLocalStorage = testSupport();\n        }\n\n        return this._supportsLocalStorage;\n    }\n}\n","import { JqTreeWidget } from \"./tree.jquery\";\nimport { HitArea, PositionInfo } from \"./types\";\n\nexport default class ScrollHandler {\n    private treeWidget: JqTreeWidget;\n    private previousTop: number;\n    private isInitialized: boolean;\n    private $scrollParent: JQuery | null;\n    private scrollParentTop: number;\n\n    constructor(treeWidget: JqTreeWidget) {\n        this.treeWidget = treeWidget;\n        this.previousTop = -1;\n        this.isInitialized = false;\n    }\n\n    public checkScrolling(): void {\n        this.ensureInit();\n        this.checkVerticalScrolling();\n        this.checkHorizontalScrolling();\n    }\n\n    public scrollToY(top: number): void {\n        this.ensureInit();\n\n        if (this.$scrollParent) {\n            this.$scrollParent[0].scrollTop = top;\n        } else {\n            const offset = this.treeWidget.$el.offset();\n            const treeTop = offset ? offset.top : 0;\n\n            jQuery(document).scrollTop(top + treeTop);\n        }\n    }\n\n    public isScrolledIntoView($element: JQuery): boolean {\n        this.ensureInit();\n\n        let elementBottom: number;\n        let viewBottom: number;\n        let elementTop: number;\n        let viewTop: number;\n\n        const elHeight = $element.height() || 0;\n\n        if (this.$scrollParent) {\n            viewTop = 0;\n            viewBottom = this.$scrollParent.height() || 0;\n\n            const offset = $element.offset();\n            const originalTop = offset ? offset.top : 0;\n\n            elementTop = originalTop - this.scrollParentTop;\n            elementBottom = elementTop + elHeight;\n        } else {\n            viewTop = jQuery(window).scrollTop() || 0;\n\n            const windowHeight = jQuery(window).height() || 0;\n            viewBottom = viewTop + windowHeight;\n\n            const offset = $element.offset();\n\n            elementTop = offset ? offset.top : 0;\n            elementBottom = elementTop + elHeight;\n        }\n\n        return elementBottom <= viewBottom && elementTop >= viewTop;\n    }\n\n    public getScrollLeft(): number {\n        if (!this.$scrollParent) {\n            return 0;\n        } else {\n            return this.$scrollParent.scrollLeft() || 0;\n        }\n    }\n\n    private initScrollParent(): void {\n        const getParentWithOverflow = (): JQuery | null => {\n            const cssAttributes = [\"overflow\", \"overflow-y\"];\n\n            const hasOverFlow = ($el: JQuery): boolean => {\n                for (const attr of cssAttributes) {\n                    const overflowValue = $el.css(attr);\n                    if (\n                        overflowValue === \"auto\" ||\n                        overflowValue === \"scroll\"\n                    ) {\n                        return true;\n                    }\n                }\n\n                return false;\n            };\n\n            if (hasOverFlow(this.treeWidget.$el)) {\n                return this.treeWidget.$el;\n            }\n\n            for (const el of this.treeWidget.$el.parents().get()) {\n                const $el = jQuery(el);\n                if (hasOverFlow($el)) {\n                    return $el;\n                }\n            }\n\n            return null;\n        };\n\n        const setDocumentAsScrollParent = (): void => {\n            this.scrollParentTop = 0;\n            this.$scrollParent = null;\n        };\n\n        if (this.treeWidget.$el.css(\"position\") === \"fixed\") {\n            setDocumentAsScrollParent();\n        }\n\n        const $scrollParent = getParentWithOverflow();\n\n        if (\n            $scrollParent &&\n            $scrollParent.length &&\n            $scrollParent[0].tagName !== \"HTML\"\n        ) {\n            this.$scrollParent = $scrollParent;\n\n            const offset = this.$scrollParent.offset();\n            this.scrollParentTop = offset ? offset.top : 0;\n        } else {\n            setDocumentAsScrollParent();\n        }\n\n        this.isInitialized = true;\n    }\n\n    private ensureInit(): void {\n        if (!this.isInitialized) {\n            this.initScrollParent();\n        }\n    }\n\n    private handleVerticalScrollingWithScrollParent(area: HitArea): void {\n        const scrollParent = this.$scrollParent && this.$scrollParent[0];\n\n        if (!scrollParent) {\n            return;\n        }\n\n        const distanceBottom =\n            this.scrollParentTop + scrollParent.offsetHeight - area.bottom;\n\n        if (distanceBottom < 20) {\n            scrollParent.scrollTop += 20;\n            this.treeWidget.refreshHitAreas();\n            this.previousTop = -1;\n        } else if (area.top - this.scrollParentTop < 20) {\n            scrollParent.scrollTop -= 20;\n            this.treeWidget.refreshHitAreas();\n            this.previousTop = -1;\n        }\n    }\n\n    private handleVerticalScrollingWithDocument(area: HitArea): void {\n        const scrollTop = jQuery(document).scrollTop() || 0;\n        const distanceTop = area.top - scrollTop;\n\n        if (distanceTop < 20) {\n            jQuery(document).scrollTop(scrollTop - 20);\n        } else {\n            const windowHeight = jQuery(window).height() || 0;\n\n            if (windowHeight - (area.bottom - scrollTop) < 20) {\n                jQuery(document).scrollTop(scrollTop + 20);\n            }\n        }\n    }\n\n    private checkVerticalScrolling(): void {\n        const hoveredArea = this.treeWidget.dndHandler.hoveredArea;\n\n        if (hoveredArea && hoveredArea.top !== this.previousTop) {\n            this.previousTop = hoveredArea.top;\n\n            if (this.$scrollParent) {\n                this.handleVerticalScrollingWithScrollParent(hoveredArea);\n            } else {\n                this.handleVerticalScrollingWithDocument(hoveredArea);\n            }\n        }\n    }\n\n    private checkHorizontalScrolling(): void {\n        const positionInfo = this.treeWidget.dndHandler.positionInfo;\n\n        if (!positionInfo) {\n            return;\n        }\n\n        if (this.$scrollParent) {\n            this.handleHorizontalScrollingWithParent(positionInfo);\n        } else {\n            this.handleHorizontalScrollingWithDocument(positionInfo);\n        }\n    }\n\n    private handleHorizontalScrollingWithParent(\n        positionInfo: PositionInfo\n    ): void {\n        if (\n            positionInfo.pageX === undefined ||\n            positionInfo.pageY === undefined\n        ) {\n            return;\n        }\n\n        const $scrollParent = this.$scrollParent;\n        const scrollParentOffset = $scrollParent && $scrollParent.offset();\n\n        if (!($scrollParent && scrollParentOffset)) {\n            return;\n        }\n\n        const scrollParent = $scrollParent[0];\n\n        const canScrollRight =\n            scrollParent.scrollLeft + scrollParent.clientWidth <\n            scrollParent.scrollWidth;\n        const canScrollLeft = scrollParent.scrollLeft > 0;\n\n        const rightEdge = scrollParentOffset.left + scrollParent.clientWidth;\n        const leftEdge = scrollParentOffset.left;\n        const isNearRightEdge = positionInfo.pageX > rightEdge - 20;\n        const isNearLeftEdge = positionInfo.pageX < leftEdge + 20;\n\n        if (isNearRightEdge && canScrollRight) {\n            scrollParent.scrollLeft = Math.min(\n                scrollParent.scrollLeft + 20,\n                scrollParent.scrollWidth\n            );\n        } else if (isNearLeftEdge && canScrollLeft) {\n            scrollParent.scrollLeft = Math.max(scrollParent.scrollLeft - 20, 0);\n        }\n    }\n\n    private handleHorizontalScrollingWithDocument(\n        positionInfo: PositionInfo\n    ): void {\n        if (\n            positionInfo.pageX === undefined ||\n            positionInfo.pageY === undefined\n        ) {\n            return;\n        }\n\n        const $document = jQuery(document);\n\n        const scrollLeft = $document.scrollLeft() || 0;\n        const windowWidth = jQuery(window).width() || 0;\n\n        const canScrollLeft = scrollLeft > 0;\n\n        const isNearRightEdge = positionInfo.pageX > windowWidth - 20;\n        const isNearLeftEdge = positionInfo.pageX - scrollLeft < 20;\n\n        if (isNearRightEdge) {\n            $document.scrollLeft(scrollLeft + 20);\n        } else if (isNearLeftEdge && canScrollLeft) {\n            $document.scrollLeft(Math.max(scrollLeft - 20, 0));\n        }\n    }\n}\n","import { Node, NodeId } from \"./node\";\nimport { JqTreeWidget } from \"./tree.jquery\";\n\nexport default class SelectNodeHandler {\n    private treeWidget: JqTreeWidget;\n    private selectedNodes: Record<NodeId, boolean>;\n    private selectedSingleNode: Node | null;\n\n    constructor(treeWidget: JqTreeWidget) {\n        this.treeWidget = treeWidget;\n        this.clear();\n    }\n\n    public getSelectedNode(): Node | false {\n        const selectedNodes = this.getSelectedNodes();\n\n        if (selectedNodes.length) {\n            return selectedNodes[0];\n        } else {\n            return false;\n        }\n    }\n\n    public getSelectedNodes(): Node[] {\n        if (this.selectedSingleNode) {\n            return [this.selectedSingleNode];\n        } else {\n            const selectedNodes = [];\n\n            for (const id in this.selectedNodes) {\n                if (\n                    Object.prototype.hasOwnProperty.call(this.selectedNodes, id)\n                ) {\n                    const node = this.treeWidget.getNodeById(id);\n                    if (node) {\n                        selectedNodes.push(node);\n                    }\n                }\n            }\n\n            return selectedNodes;\n        }\n    }\n\n    public getSelectedNodesUnder(parent: Node): Node[] {\n        if (this.selectedSingleNode) {\n            if (parent.isParentOf(this.selectedSingleNode)) {\n                return [this.selectedSingleNode];\n            } else {\n                return [];\n            }\n        } else {\n            const selectedNodes = [];\n\n            for (const id in this.selectedNodes) {\n                if (\n                    Object.prototype.hasOwnProperty.call(this.selectedNodes, id)\n                ) {\n                    const node = this.treeWidget.getNodeById(id);\n                    if (node && parent.isParentOf(node)) {\n                        selectedNodes.push(node);\n                    }\n                }\n            }\n\n            return selectedNodes;\n        }\n    }\n\n    public isNodeSelected(node: Node): boolean {\n        if (node.id != null) {\n            if (this.selectedNodes[node.id]) {\n                return true;\n            } else {\n                return false;\n            }\n        } else if (this.selectedSingleNode) {\n            return this.selectedSingleNode.element === node.element;\n        } else {\n            return false;\n        }\n    }\n\n    public clear(): void {\n        this.selectedNodes = {};\n        this.selectedSingleNode = null;\n    }\n\n    public removeFromSelection(node: Node, includeChildren = false): void {\n        if (node.id == null) {\n            if (\n                this.selectedSingleNode &&\n                node.element === this.selectedSingleNode.element\n            ) {\n                this.selectedSingleNode = null;\n            }\n        } else {\n            delete this.selectedNodes[node.id];\n\n            if (includeChildren) {\n                node.iterate(() => {\n                    if (node.id != null) {\n                        delete this.selectedNodes[node.id];\n                    }\n                    return true;\n                });\n            }\n        }\n    }\n\n    public addToSelection(node: Node): void {\n        if (node.id != null) {\n            this.selectedNodes[node.id] = true;\n        } else {\n            this.selectedSingleNode = node;\n        }\n    }\n\n    public isFocusOnTree(): boolean {\n        const activeElement = document.activeElement;\n\n        return Boolean(\n            activeElement &&\n                activeElement.tagName === \"SPAN\" &&\n                this.treeWidget._containsElement(activeElement as HTMLElement)\n        );\n    }\n}\n","import { Position, Node } from \"./node\";\nimport { JqTreeWidget } from \"./tree.jquery\";\nimport { DropHint } from \"./types\";\n\nexport type OnFinishOpenNode = (node: Node) => void;\n\nexport class NodeElement {\n    public node: Node;\n    public $element: JQuery<HTMLElement>;\n    protected treeWidget: JqTreeWidget;\n\n    constructor(node: Node, treeWidget: JqTreeWidget) {\n        this.init(node, treeWidget);\n    }\n\n    public init(node: Node, treeWidget: JqTreeWidget): void {\n        this.node = node;\n        this.treeWidget = treeWidget;\n\n        if (!node.element) {\n            node.element = this.treeWidget.element.get(0);\n        }\n\n        this.$element = jQuery(node.element);\n    }\n\n    public addDropHint(position: number): DropHint {\n        if (this.mustShowBorderDropHint(position)) {\n            return new BorderDropHint(\n                this.$element,\n                this.treeWidget._getScrollLeft()\n            );\n        } else {\n            return new GhostDropHint(this.node, this.$element, position);\n        }\n    }\n\n    public select(mustSetFocus: boolean): void {\n        const $li = this.getLi();\n\n        $li.addClass(\"jqtree-selected\");\n        $li.attr(\"aria-selected\", \"true\");\n\n        const $span = this.getSpan();\n        $span.attr(\"tabindex\", this.treeWidget.options.tabIndex ?? null);\n\n        if (mustSetFocus) {\n            $span.trigger(\"focus\");\n        }\n    }\n\n    public deselect(): void {\n        const $li = this.getLi();\n\n        $li.removeClass(\"jqtree-selected\");\n        $li.attr(\"aria-selected\", \"false\");\n\n        const $span = this.getSpan();\n        $span.removeAttr(\"tabindex\");\n\n        $span.blur();\n    }\n\n    protected getUl(): JQuery<HTMLElement> {\n        return this.$element.children(\"ul:first\");\n    }\n\n    protected getSpan(): JQuery<HTMLElement> {\n        return this.$element\n            .children(\".jqtree-element\")\n            .find(\"span.jqtree-title\");\n    }\n\n    protected getLi(): JQuery<HTMLElement> {\n        return this.$element;\n    }\n\n    protected mustShowBorderDropHint(position: number): boolean {\n        return position === Position.Inside;\n    }\n}\n\nexport class FolderElement extends NodeElement {\n    public open(\n        onFinished: OnFinishOpenNode | null,\n        slide = true,\n        animationSpeed: JQuery.Duration | string = \"fast\"\n    ): void {\n        if (this.node.is_open) {\n            return;\n        }\n\n        this.node.is_open = true;\n\n        const $button = this.getButton();\n        $button.removeClass(\"jqtree-closed\");\n        $button.html(\"\");\n\n        const buttonEl = $button.get(0);\n\n        if (buttonEl) {\n            const icon = this.treeWidget.renderer.openedIconElement.cloneNode(\n                true\n            );\n\n            buttonEl.appendChild(icon);\n        }\n\n        const doOpen = (): void => {\n            const $li = this.getLi();\n            $li.removeClass(\"jqtree-closed\");\n\n            const $span = this.getSpan();\n            $span.attr(\"aria-expanded\", \"true\");\n\n            if (onFinished) {\n                onFinished(this.node);\n            }\n\n            this.treeWidget._triggerEvent(\"tree.open\", {\n                node: this.node,\n            });\n        };\n\n        if (slide) {\n            this.getUl().slideDown(animationSpeed, doOpen);\n        } else {\n            this.getUl().show();\n            doOpen();\n        }\n    }\n\n    public close(\n        slide = true,\n        animationSpeed: JQuery.Duration | string = \"fast\"\n    ): void {\n        if (!this.node.is_open) {\n            return;\n        }\n\n        this.node.is_open = false;\n\n        const $button = this.getButton();\n        $button.addClass(\"jqtree-closed\");\n        $button.html(\"\");\n\n        const buttonEl = $button.get(0);\n\n        if (buttonEl) {\n            const icon = this.treeWidget.renderer.closedIconElement.cloneNode(\n                true\n            );\n\n            buttonEl.appendChild(icon);\n        }\n\n        const doClose = (): void => {\n            const $li = this.getLi();\n            $li.addClass(\"jqtree-closed\");\n\n            const $span = this.getSpan();\n            $span.attr(\"aria-expanded\", \"false\");\n\n            this.treeWidget._triggerEvent(\"tree.close\", {\n                node: this.node,\n            });\n        };\n\n        if (slide) {\n            this.getUl().slideUp(animationSpeed, doClose);\n        } else {\n            this.getUl().hide();\n            doClose();\n        }\n    }\n\n    protected mustShowBorderDropHint(position: number): boolean {\n        return !this.node.is_open && position === Position.Inside;\n    }\n\n    private getButton(): JQuery {\n        return this.$element\n            .children(\".jqtree-element\")\n            .find(\"a.jqtree-toggler\");\n    }\n}\n\nexport class BorderDropHint implements DropHint {\n    private $hint: JQuery<Element>;\n\n    constructor($element: JQuery<Element>, scrollLeft: number) {\n        const $div = $element.children(\".jqtree-element\");\n\n        const elWidth = $element.width() || 0;\n        const width = Math.max(elWidth + scrollLeft - 4, 0);\n\n        const elHeight = $div.outerHeight() || 0;\n        const height = Math.max(elHeight - 4, 0);\n\n        this.$hint = jQuery('<span class=\"jqtree-border\"></span>');\n        $div.append(this.$hint);\n\n        this.$hint.css({ width, height });\n    }\n\n    public remove(): void {\n        this.$hint.remove();\n    }\n}\n\nclass GhostDropHint implements DropHint {\n    private $element: JQuery<Element>;\n    private node: Node;\n    private $ghost: JQuery;\n\n    constructor(node: Node, $element: JQuery<Element>, position: number) {\n        this.$element = $element;\n\n        this.node = node;\n        this.$ghost = jQuery(\n            `<li class=\"jqtree_common jqtree-ghost\"><span class=\"jqtree_common jqtree-circle\"></span>\n            <span class=\"jqtree_common jqtree-line\"></span></li>`\n        );\n\n        if (position === Position.After) {\n            this.moveAfter();\n        } else if (position === Position.Before) {\n            this.moveBefore();\n        } else if (position === Position.Inside) {\n            if (node.isFolder() && node.is_open) {\n                this.moveInsideOpenFolder();\n            } else {\n                this.moveInside();\n            }\n        }\n    }\n\n    public remove(): void {\n        this.$ghost.remove();\n    }\n\n    public moveAfter(): void {\n        this.$element.after(this.$ghost);\n    }\n\n    public moveBefore(): void {\n        this.$element.before(this.$ghost);\n    }\n\n    public moveInsideOpenFolder(): void {\n        jQuery(this.node.children[0].element).before(this.$ghost);\n    }\n\n    public moveInside(): void {\n        this.$element.after(this.$ghost);\n        this.$ghost.addClass(\"jqtree-inside\");\n    }\n}\n","import __version__ from \"./version\";\nimport * as jQueryProxy from \"jquery\";\nimport { DragAndDropHandler } from \"./dragAndDropHandler\";\nimport ElementsRenderer from \"./elementsRenderer\";\nimport DataLoader, { HandleFinishedLoading } from \"./dataLoader\";\nimport KeyHandler from \"./keyHandler\";\nimport MouseWidget from \"./mouse.widget\";\nimport { PositionInfo } from \"./types\";\nimport SaveStateHandler from \"./saveStateHandler\";\nimport ScrollHandler from \"./scrollHandler\";\nimport SelectNodeHandler from \"./selectNodeHandler\";\nimport SimpleWidget from \"./simple.widget\";\nimport { Node, NodeId, getPosition, NodeData } from \"./node\";\nimport { isFunction } from \"./util\";\nimport { FolderElement, NodeElement, OnFinishOpenNode } from \"./nodeElement\";\nimport { JQTreeOptions } from \"./jqtreeOptions\";\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\nconst jQuery: JQueryStatic = (<any>jQueryProxy).default || jQueryProxy;\n\ninterface ClickTarget {\n    node: Node;\n    type: \"button\" | \"label\";\n}\n\ninterface SelectNodeOptions {\n    mustToggle?: boolean;\n    mustSetFocus?: boolean;\n}\n\nconst NODE_PARAM_IS_EMPTY = \"Node parameter is empty\";\nconst PARAM_IS_EMPTY = \"Parameter is empty: \";\n\nexport class JqTreeWidget extends MouseWidget<JQTreeOptions> {\n    protected static defaults: JQTreeOptions = {\n        animationSpeed: \"fast\",\n        autoOpen: false, // true / false / int (open n levels starting at 0)\n        saveState: false, // true / false / string (cookie name)\n        dragAndDrop: false,\n        selectable: true,\n        useContextMenu: true,\n        onCanSelectNode: undefined,\n        onSetStateFromStorage: undefined,\n        onGetStateFromStorage: undefined,\n        onCreateLi: undefined,\n        onIsMoveHandle: undefined,\n\n        // Can this node be moved?\n        onCanMove: undefined,\n\n        // Can this node be moved to this position? function(moved_node, target_node, position)\n        onCanMoveTo: undefined,\n        onLoadFailed: undefined,\n        autoEscape: true,\n        dataUrl: undefined,\n\n        // The symbol to use for a closed node - ► BLACK RIGHT-POINTING POINTER\n        // http://www.fileformat.info/info/unicode/char/25ba/index.htm\n        closedIcon: undefined,\n\n        // The symbol to use for an open node - ▼ BLACK DOWN-POINTING TRIANGLE\n        // http://www.fileformat.info/info/unicode/char/25bc/index.htm\n        openedIcon: \"&#x25bc;\",\n        slide: true, // must display slide animation?\n        nodeClass: Node,\n        dataFilter: undefined,\n        keyboardSupport: true,\n        openFolderDelay: 500, // The delay for opening a folder during drag and drop; the value is in milliseconds\n        startDndDelay: 300, // The delay for starting dnd (in milliseconds)\n        rtl: undefined, // right-to-left support; true / false (default)\n        onDragMove: undefined,\n        onDragStop: undefined,\n        buttonLeft: true,\n        onLoading: undefined,\n        showEmptyFolder: false,\n        tabIndex: 0,\n    };\n\n    public element: JQuery;\n    public tree: Node;\n    public dndHandler: DragAndDropHandler;\n    public renderer: ElementsRenderer;\n    public dataLoader: DataLoader;\n    public scrollHandler: ScrollHandler;\n    public selectNodeHandler: SelectNodeHandler;\n\n    private isInitialized: boolean;\n    private saveStateHandler: SaveStateHandler;\n    private keyHandler: KeyHandler;\n\n    public toggle(node: Node, slideParam: null | boolean = null): JQuery {\n        if (!node) {\n            throw Error(NODE_PARAM_IS_EMPTY);\n        }\n\n        const slide = slideParam ?? this.options.slide;\n\n        if (node.is_open) {\n            this.closeNode(node, slide);\n        } else {\n            this.openNode(node, slide);\n        }\n\n        return this.element;\n    }\n\n    public getTree(): Node {\n        return this.tree;\n    }\n\n    public selectNode(\n        node: Node | null,\n        optionsParam?: SelectNodeOptions\n    ): JQuery {\n        this.doSelectNode(node, optionsParam);\n        return this.element;\n    }\n\n    public getSelectedNode(): Node | false {\n        return this.selectNodeHandler.getSelectedNode();\n    }\n\n    public toJson(): string {\n        return JSON.stringify(this.tree.getData());\n    }\n\n    public loadData(data: NodeData[], parentNode: Node | null): JQuery {\n        this.doLoadData(data, parentNode);\n        return this.element;\n    }\n\n    /*\n    signatures:\n    - loadDataFromUrl(url, parent_node=null, on_finished=null)\n        loadDataFromUrl('/my_data');\n        loadDataFromUrl('/my_data', node1);\n        loadDataFromUrl('/my_data', node1, function() { console.log('finished'); });\n        loadDataFromUrl('/my_data', null, function() { console.log('finished'); });\n\n    - loadDataFromUrl(parent_node=null, on_finished=null)\n        loadDataFromUrl();\n        loadDataFromUrl(node1);\n        loadDataFromUrl(null, function() { console.log('finished'); });\n        loadDataFromUrl(node1, function() { console.log('finished'); });\n    */\n    public loadDataFromUrl(\n        param1: string | null | Node,\n        param2?: Node | null | HandleFinishedLoading,\n        param3?: HandleFinishedLoading\n    ): JQuery {\n        if (typeof param1 === \"string\") {\n            // first parameter is url\n            this.doLoadDataFromUrl(\n                param1,\n                param2 as Node | null,\n                param3 ?? null\n            );\n        } else {\n            // first parameter is not url\n            this.doLoadDataFromUrl(\n                null,\n                param1,\n                param2 as HandleFinishedLoading | null\n            );\n        }\n\n        return this.element;\n    }\n\n    public reload(onFinished: HandleFinishedLoading | null): JQuery {\n        this.doLoadDataFromUrl(null, null, onFinished);\n        return this.element;\n    }\n\n    public getNodeById(nodeId: NodeId): Node | null {\n        return this.tree.getNodeById(nodeId);\n    }\n\n    public getNodeByName(name: string): Node | null {\n        return this.tree.getNodeByName(name);\n    }\n\n    public getNodeByNameMustExist(name: string): Node {\n        return this.tree.getNodeByNameMustExist(name);\n    }\n\n    public getNodesByProperty(key: string, value: unknown): Node[] {\n        return this.tree.getNodesByProperty(key, value);\n    }\n\n    public getNodeByHtmlElement(\n        element: HTMLElement | JQuery<HTMLElement>\n    ): Node | null {\n        return this.getNode(jQuery(element));\n    }\n\n    public getNodeByCallback(callback: (node: Node) => boolean): Node | null {\n        return this.tree.getNodeByCallback(callback);\n    }\n\n    public openNode(\n        node: Node,\n        param1?: boolean | OnFinishOpenNode,\n        param2?: OnFinishOpenNode\n    ): JQuery {\n        if (!node) {\n            throw Error(NODE_PARAM_IS_EMPTY);\n        }\n\n        const parseParams = (): [boolean, OnFinishOpenNode | null] => {\n            let onFinished: OnFinishOpenNode | null;\n            let slide: boolean | null;\n\n            if (isFunction(param1)) {\n                onFinished = param1 as OnFinishOpenNode | null;\n                slide = null;\n            } else {\n                slide = param1 as boolean;\n                onFinished = param2 as OnFinishOpenNode;\n            }\n\n            if (slide == null) {\n                slide = this.options.slide ?? false;\n            }\n\n            return [slide, onFinished];\n        };\n\n        const [slide, onFinished] = parseParams();\n\n        this._openNode(node, slide, onFinished);\n        return this.element;\n    }\n\n    public closeNode(node: Node, slideParam?: null | boolean): JQuery {\n        if (!node) {\n            throw Error(NODE_PARAM_IS_EMPTY);\n        }\n\n        const slide = slideParam ?? this.options.slide;\n\n        if (node.isFolder() || node.isEmptyFolder) {\n            new FolderElement(node, this).close(\n                slide,\n                this.options.animationSpeed\n            );\n\n            this.saveState();\n        }\n\n        return this.element;\n    }\n\n    public isDragging(): boolean {\n        return this.dndHandler.isDragging;\n    }\n\n    public refreshHitAreas(): JQuery {\n        this.dndHandler.refresh();\n        return this.element;\n    }\n\n    public addNodeAfter(\n        newNodeInfo: NodeData,\n        existingNode: Node\n    ): Node | null {\n        const newNode = existingNode.addAfter(newNodeInfo);\n\n        if (newNode) {\n            this._refreshElements(existingNode.parent);\n        }\n\n        return newNode;\n    }\n\n    public addNodeBefore(\n        newNodeInfo: NodeData,\n        existingNode: Node\n    ): Node | null {\n        if (!existingNode) {\n            throw Error(PARAM_IS_EMPTY + \"existingNode\");\n        }\n\n        const newNode = existingNode.addBefore(newNodeInfo);\n\n        if (newNode) {\n            this._refreshElements(existingNode.parent);\n        }\n\n        return newNode;\n    }\n\n    public addParentNode(\n        newNodeInfo: NodeData,\n        existingNode: Node\n    ): Node | null {\n        if (!existingNode) {\n            throw Error(PARAM_IS_EMPTY + \"existingNode\");\n        }\n\n        const newNode = existingNode.addParent(newNodeInfo);\n\n        if (newNode) {\n            this._refreshElements(newNode.parent);\n        }\n\n        return newNode;\n    }\n\n    public removeNode(node: Node): JQuery {\n        if (!node) {\n            throw Error(NODE_PARAM_IS_EMPTY);\n        }\n\n        if (!node.parent) {\n            throw Error(\"Node has no parent\");\n        }\n\n        this.selectNodeHandler.removeFromSelection(node, true); // including children\n\n        const parent = node.parent;\n        node.remove();\n        this._refreshElements(parent);\n\n        return this.element;\n    }\n\n    public appendNode(newNodeInfo: NodeData, parentNodeParam?: Node): Node {\n        const parentNode = parentNodeParam || this.tree;\n\n        const node = parentNode.append(newNodeInfo);\n\n        this._refreshElements(parentNode);\n\n        return node;\n    }\n\n    public prependNode(newNodeInfo: NodeData, parentNodeParam?: Node): Node {\n        const parentNode = parentNodeParam ?? this.tree;\n\n        const node = parentNode.prepend(newNodeInfo);\n\n        this._refreshElements(parentNode);\n\n        return node;\n    }\n\n    public updateNode(node: Node, data: NodeData): JQuery {\n        if (!node) {\n            throw Error(NODE_PARAM_IS_EMPTY);\n        }\n\n        const idIsChanged =\n            typeof data === \"object\" && data.id && data.id !== node.id;\n\n        if (idIsChanged) {\n            this.tree.removeNodeFromIndex(node);\n        }\n\n        node.setData(data);\n\n        if (idIsChanged) {\n            this.tree.addNodeToIndex(node);\n        }\n\n        if (\n            typeof data === \"object\" &&\n            data[\"children\"] &&\n            data[\"children\"] instanceof Array\n        ) {\n            node.removeChildren();\n\n            if (data.children.length) {\n                node.loadFromData(data.children);\n            }\n        }\n\n        const mustSetFocus = this.selectNodeHandler.isFocusOnTree();\n        const mustSelect = this.isSelectedNodeInSubtree(node);\n\n        this._refreshElements(node);\n\n        if (mustSelect) {\n            this.selectCurrentNode(mustSetFocus);\n        }\n\n        return this.element;\n    }\n\n    private isSelectedNodeInSubtree(subtree: Node): boolean {\n        const selectedNode = this.getSelectedNode();\n\n        if (!selectedNode) {\n            return false;\n        } else {\n            return subtree === selectedNode || subtree.isParentOf(selectedNode);\n        }\n    }\n\n    public moveNode(node: Node, targetNode: Node, position: string): JQuery {\n        if (!node) {\n            throw Error(NODE_PARAM_IS_EMPTY);\n        }\n\n        if (!targetNode) {\n            throw Error(PARAM_IS_EMPTY + \"targetNode\");\n        }\n\n        const positionIndex = getPosition(position);\n\n        if (positionIndex !== undefined) {\n            this.tree.moveNode(node, targetNode, positionIndex);\n            this._refreshElements(null);\n        }\n\n        return this.element;\n    }\n\n    public getStateFromStorage(): SavedState | null {\n        return this.saveStateHandler.getStateFromStorage();\n    }\n\n    public addToSelection(node: Node, mustSetFocus?: boolean): JQuery {\n        if (!node) {\n            throw Error(NODE_PARAM_IS_EMPTY);\n        }\n\n        this.selectNodeHandler.addToSelection(node);\n\n        this._getNodeElementForNode(node).select(\n            mustSetFocus === undefined ? true : mustSetFocus\n        );\n\n        this.saveState();\n\n        return this.element;\n    }\n\n    public getSelectedNodes(): Node[] {\n        return this.selectNodeHandler.getSelectedNodes();\n    }\n\n    public isNodeSelected(node: Node): boolean {\n        if (!node) {\n            throw Error(NODE_PARAM_IS_EMPTY);\n        }\n\n        return this.selectNodeHandler.isNodeSelected(node);\n    }\n\n    public removeFromSelection(node: Node): JQuery {\n        if (!node) {\n            throw Error(NODE_PARAM_IS_EMPTY);\n        }\n\n        this.selectNodeHandler.removeFromSelection(node);\n\n        this._getNodeElementForNode(node).deselect();\n        this.saveState();\n\n        return this.element;\n    }\n\n    public scrollToNode(node: Node): JQuery {\n        if (!node) {\n            throw Error(NODE_PARAM_IS_EMPTY);\n        }\n\n        const nodeOffset = jQuery(node.element).offset();\n        const nodeTop = nodeOffset ? nodeOffset.top : 0;\n\n        const treeOffset = this.$el.offset();\n        const treeTop = treeOffset ? treeOffset.top : 0;\n\n        const top = nodeTop - treeTop;\n\n        this.scrollHandler.scrollToY(top);\n\n        return this.element;\n    }\n\n    public getState(): SavedState | null {\n        return this.saveStateHandler.getState();\n    }\n\n    public setState(state: SavedState): JQuery {\n        this.saveStateHandler.setInitialState(state);\n        this._refreshElements(null);\n\n        return this.element;\n    }\n\n    public setOption(option: string, value: unknown): JQuery {\n        (this.options as Record<string, unknown>)[option] = value;\n        return this.element;\n    }\n\n    public moveDown(): JQuery {\n        const selectedNode = this.getSelectedNode();\n        if (selectedNode) {\n            this.keyHandler.moveDown(selectedNode);\n        }\n\n        return this.element;\n    }\n\n    public moveUp(): JQuery {\n        const selectedNode = this.getSelectedNode();\n        if (selectedNode) {\n            this.keyHandler.moveUp(selectedNode);\n        }\n\n        return this.element;\n    }\n\n    public getVersion(): string {\n        return __version__;\n    }\n\n    public _triggerEvent(\n        eventName: string,\n        values?: DefaultRecord\n    ): JQuery.Event {\n        const event = jQuery.Event(eventName, values);\n        this.element.trigger(event);\n        return event;\n    }\n\n    public _openNode(\n        node: Node,\n        slide = true,\n        onFinished: OnFinishOpenNode | null\n    ): void {\n        const doOpenNode = (\n            _node: Node,\n            _slide: any,\n            _onFinished: OnFinishOpenNode | null\n        ): void => {\n            const folderElement = new FolderElement(_node, this);\n            folderElement.open(\n                _onFinished,\n                _slide,\n                this.options.animationSpeed\n            );\n        };\n\n        if (node.isFolder() || node.isEmptyFolder) {\n            if (node.load_on_demand) {\n                this.loadFolderOnDemand(node, slide, onFinished);\n            } else {\n                let parent = node.parent;\n\n                while (parent) {\n                    // nb: do not open root element\n                    if (parent.parent) {\n                        doOpenNode(parent, false, null);\n                    }\n                    parent = parent.parent;\n                }\n\n                doOpenNode(node, slide, onFinished);\n                this.saveState();\n            }\n        }\n    }\n\n    /*\n    Redraw the tree or part of the tree.\n     from_node: redraw this subtree\n    */\n    public _refreshElements(fromNode: Node | null): void {\n        this.renderer.render(fromNode);\n\n        this._triggerEvent(\"tree.refresh\");\n    }\n\n    public _getNodeElementForNode(node: Node): NodeElement {\n        if (node.isFolder()) {\n            return new FolderElement(node, this);\n        } else {\n            return new NodeElement(node, this);\n        }\n    }\n\n    public _getNodeElement($element: JQuery<HTMLElement>): NodeElement | null {\n        const node = this.getNode($element);\n        if (node) {\n            return this._getNodeElementForNode(node);\n        } else {\n            return null;\n        }\n    }\n\n    public _containsElement(element: HTMLElement): boolean {\n        const node = this.getNode(jQuery(element));\n\n        return node != null && node.tree === this.tree;\n    }\n\n    public _getScrollLeft(): number {\n        return this.scrollHandler.getScrollLeft();\n    }\n\n    public init(): void {\n        super.init();\n\n        this.element = this.$el;\n        this.isInitialized = false;\n\n        this.options.rtl = this.getRtlOption();\n\n        if (this.options.closedIcon == null) {\n            this.options.closedIcon = this.getDefaultClosedIcon();\n        }\n\n        this.renderer = new ElementsRenderer(this);\n        this.dataLoader = new DataLoader(this);\n        this.saveStateHandler = new SaveStateHandler(this);\n        this.selectNodeHandler = new SelectNodeHandler(this);\n        this.dndHandler = new DragAndDropHandler(this);\n        this.scrollHandler = new ScrollHandler(this);\n        this.keyHandler = new KeyHandler(this);\n\n        this.initData();\n\n        this.element.on(\"click\", this.handleClick);\n        this.element.on(\"dblclick\", this.handleDblclick);\n\n        if (this.options.useContextMenu) {\n            this.element.on(\"contextmenu\", this.handleContextmenu);\n        }\n    }\n\n    public deinit(): void {\n        this.element.empty();\n        this.element.off();\n\n        this.keyHandler.deinit();\n\n        this.tree = new Node({}, true);\n\n        super.deinit();\n    }\n\n    protected mouseCapture(positionInfo: PositionInfo): boolean | null {\n        if (this.options.dragAndDrop) {\n            return this.dndHandler.mouseCapture(positionInfo);\n        } else {\n            return false;\n        }\n    }\n\n    protected mouseStart(positionInfo: PositionInfo): boolean {\n        if (this.options.dragAndDrop) {\n            return this.dndHandler.mouseStart(positionInfo);\n        } else {\n            return false;\n        }\n    }\n\n    protected mouseDrag(positionInfo: PositionInfo): boolean {\n        if (this.options.dragAndDrop) {\n            const result = this.dndHandler.mouseDrag(positionInfo);\n\n            this.scrollHandler.checkScrolling();\n            return result;\n        } else {\n            return false;\n        }\n    }\n\n    protected mouseStop(positionInfo: PositionInfo): boolean {\n        if (this.options.dragAndDrop) {\n            return this.dndHandler.mouseStop(positionInfo);\n        } else {\n            return false;\n        }\n    }\n\n    protected getMouseDelay(): number {\n        return this.options.startDndDelay ?? 0;\n    }\n\n    private initData(): void {\n        if (this.options.data) {\n            this.doLoadData(this.options.data, null);\n        } else {\n            const dataUrl = this.getDataUrlInfo(null);\n\n            if (dataUrl) {\n                this.doLoadDataFromUrl(null, null, null);\n            } else {\n                this.doLoadData([], null);\n            }\n        }\n    }\n\n    private getDataUrlInfo(node: Node | null): JQuery.AjaxSettings | null {\n        const dataUrl =\n            this.options.dataUrl || (this.element.data(\"url\") as string | null);\n\n        const getUrlFromString = (url: string): JQuery.AjaxSettings => {\n            const urlInfo: JQuery.AjaxSettings = { url };\n\n            setUrlInfoData(urlInfo);\n\n            return urlInfo;\n        };\n\n        const setUrlInfoData = (urlInfo: JQuery.AjaxSettings): void => {\n            if (node?.id) {\n                // Load on demand of a subtree; add node parameter\n                const data = { node: node.id };\n                urlInfo[\"data\"] = data;\n            } else {\n                // Add selected_node parameter\n                const selectedNodeId = this.getNodeIdToBeSelected();\n                if (selectedNodeId) {\n                    const data = { selected_node: selectedNodeId };\n                    urlInfo[\"data\"] = data;\n                }\n            }\n        };\n\n        if (typeof dataUrl === \"function\") {\n            return dataUrl(node);\n        } else if (typeof dataUrl === \"string\") {\n            return getUrlFromString(dataUrl);\n        } else if (dataUrl && typeof dataUrl === \"object\") {\n            setUrlInfoData(dataUrl);\n            return dataUrl;\n        } else {\n            return null;\n        }\n    }\n\n    private getNodeIdToBeSelected(): NodeId | null {\n        if (this.options.saveState) {\n            return this.saveStateHandler.getNodeIdToBeSelected();\n        } else {\n            return null;\n        }\n    }\n\n    private initTree(data: any): void {\n        const doInit = (): void => {\n            if (!this.isInitialized) {\n                this.isInitialized = true;\n                this._triggerEvent(\"tree.init\");\n            }\n        };\n\n        if (!this.options.nodeClass) {\n            return;\n        }\n\n        this.tree = new this.options.nodeClass(\n            null,\n            true,\n            this.options.nodeClass\n        );\n\n        this.selectNodeHandler.clear();\n\n        this.tree.loadFromData(data);\n\n        const mustLoadOnDemand = this.setInitialState();\n\n        this._refreshElements(null);\n\n        if (!mustLoadOnDemand) {\n            doInit();\n        } else {\n            // Load data on demand and then init the tree\n            this.setInitialStateOnDemand(doInit);\n        }\n    }\n\n    // Set initial state, either by restoring the state or auto-opening nodes\n    // result: must load nodes on demand?\n    private setInitialState(): boolean {\n        const restoreState = (): boolean[] => {\n            // result: is state restored, must load on demand?\n            if (!this.options.saveState) {\n                return [false, false];\n            } else {\n                const state = this.saveStateHandler.getStateFromStorage();\n\n                if (!state) {\n                    return [false, false];\n                } else {\n                    const mustLoadOnDemand = this.saveStateHandler.setInitialState(\n                        state\n                    );\n\n                    // return true: the state is restored\n                    return [true, mustLoadOnDemand];\n                }\n            }\n        };\n\n        const autoOpenNodes = (): boolean => {\n            // result: must load on demand?\n            if (this.options.autoOpen === false) {\n                return false;\n            }\n\n            const maxLevel = this.getAutoOpenMaxLevel();\n            let mustLoadOnDemand = false;\n\n            this.tree.iterate((node: Node, level: number) => {\n                if (node.load_on_demand) {\n                    mustLoadOnDemand = true;\n                    return false;\n                } else if (!node.hasChildren()) {\n                    return false;\n                } else {\n                    node.is_open = true;\n                    return level !== maxLevel;\n                }\n            });\n\n            return mustLoadOnDemand;\n        };\n\n        let [isRestored, mustLoadOnDemand] = restoreState(); // eslint-disable-line prefer-const\n\n        if (!isRestored) {\n            mustLoadOnDemand = autoOpenNodes();\n        }\n\n        return mustLoadOnDemand;\n    }\n\n    // Set the initial state for nodes that are loaded on demand\n    // Call cb_finished when done\n    private setInitialStateOnDemand(cbFinished: () => void): void {\n        const restoreState = (): boolean => {\n            if (!this.options.saveState) {\n                return false;\n            } else {\n                const state = this.saveStateHandler.getStateFromStorage();\n\n                if (!state) {\n                    return false;\n                } else {\n                    this.saveStateHandler.setInitialStateOnDemand(\n                        state,\n                        cbFinished\n                    );\n\n                    return true;\n                }\n            }\n        };\n\n        const autoOpenNodes = (): void => {\n            const maxLevel = this.getAutoOpenMaxLevel();\n            let loadingCount = 0;\n\n            const loadAndOpenNode = (node: Node): void => {\n                loadingCount += 1;\n                this._openNode(node, false, () => {\n                    loadingCount -= 1;\n                    openNodes();\n                });\n            };\n\n            const openNodes = (): void => {\n                this.tree.iterate((node: Node, level: number) => {\n                    if (node.load_on_demand) {\n                        if (!node.is_loading) {\n                            loadAndOpenNode(node);\n                        }\n\n                        return false;\n                    } else {\n                        this._openNode(node, false, null);\n\n                        return level !== maxLevel;\n                    }\n                });\n\n                if (loadingCount === 0) {\n                    cbFinished();\n                }\n            };\n\n            openNodes();\n        };\n\n        if (!restoreState()) {\n            autoOpenNodes();\n        }\n    }\n\n    private getAutoOpenMaxLevel(): number {\n        if (this.options.autoOpen === true) {\n            return -1;\n        } else if (typeof this.options.autoOpen === \"number\") {\n            return this.options.autoOpen;\n        } else if (typeof this.options.autoOpen === \"string\") {\n            return parseInt(this.options.autoOpen, 10);\n        } else {\n            return 0;\n        }\n    }\n\n    private handleClick = (e: JQuery.ClickEvent): void => {\n        const clickTarget = this.getClickTarget(e.target);\n\n        if (clickTarget) {\n            if (clickTarget.type === \"button\") {\n                this.toggle(clickTarget.node, this.options.slide);\n\n                e.preventDefault();\n                e.stopPropagation();\n            } else if (clickTarget.type === \"label\") {\n                const node = clickTarget.node;\n                const event = this._triggerEvent(\"tree.click\", {\n                    node,\n                    click_event: e,\n                });\n\n                if (!event.isDefaultPrevented()) {\n                    this.doSelectNode(node);\n                }\n            }\n        }\n    };\n\n    private handleDblclick = (e: JQuery.DoubleClickEvent): void => {\n        const clickTarget = this.getClickTarget(e.target);\n\n        if (clickTarget?.type === \"label\") {\n            this._triggerEvent(\"tree.dblclick\", {\n                node: clickTarget.node,\n                click_event: e,\n            });\n        }\n    };\n\n    private getClickTarget(element: EventTarget): ClickTarget | null {\n        const $target = jQuery(element);\n\n        const $button = $target.closest(\".jqtree-toggler\");\n\n        if ($button.length) {\n            const node = this.getNode($button as JQuery<HTMLElement>);\n\n            if (node) {\n                return {\n                    type: \"button\",\n                    node,\n                };\n            }\n        } else {\n            const $el = $target.closest(\".jqtree-element\");\n            if ($el.length) {\n                const node = this.getNode($el as JQuery<HTMLElement>);\n                if (node) {\n                    return {\n                        type: \"label\",\n                        node,\n                    };\n                }\n            }\n        }\n\n        return null;\n    }\n\n    private getNode($element: JQuery<HTMLElement>): null | Node {\n        const $li = $element.closest(\"li.jqtree_common\");\n        if ($li.length === 0) {\n            return null;\n        } else {\n            return $li.data(\"node\") as Node;\n        }\n    }\n\n    private handleContextmenu = (e: JQuery.ContextMenuEvent) => {\n        const $div = jQuery(e.target).closest(\"ul.jqtree-tree .jqtree-element\");\n        if ($div.length) {\n            const node = this.getNode($div);\n            if (node) {\n                e.preventDefault();\n                e.stopPropagation();\n\n                this._triggerEvent(\"tree.contextmenu\", {\n                    node,\n                    click_event: e,\n                });\n                return false;\n            }\n        }\n\n        return null;\n    };\n\n    private saveState(): void {\n        if (this.options.saveState) {\n            this.saveStateHandler.saveState();\n        }\n    }\n\n    private selectCurrentNode(mustSetFocus: boolean): void {\n        const node = this.getSelectedNode();\n        if (node) {\n            const nodeElement = this._getNodeElementForNode(node);\n            if (nodeElement) {\n                nodeElement.select(mustSetFocus);\n            }\n        }\n    }\n\n    private deselectCurrentNode(): void {\n        const node = this.getSelectedNode();\n        if (node) {\n            this.removeFromSelection(node);\n        }\n    }\n\n    private getDefaultClosedIcon(): string {\n        if (this.options.rtl) {\n            // triangle to the left\n            return \"&#x25c0;\";\n        } else {\n            // triangle to the right\n            return \"&#x25ba;\";\n        }\n    }\n\n    private getRtlOption(): boolean {\n        if (this.options.rtl != null) {\n            return this.options.rtl;\n        } else {\n            const dataRtl = this.element.data(\"rtl\") as unknown;\n\n            if (\n                dataRtl !== null &&\n                dataRtl !== false &&\n                dataRtl !== undefined\n            ) {\n                return true;\n            } else {\n                return false;\n            }\n        }\n    }\n\n    private doSelectNode(\n        node: Node | null,\n        optionsParam?: SelectNodeOptions\n    ): void {\n        const saveState = (): void => {\n            if (this.options.saveState) {\n                this.saveStateHandler.saveState();\n            }\n        };\n\n        if (!node) {\n            // Called with empty node -> deselect current node\n            this.deselectCurrentNode();\n            saveState();\n            return;\n        }\n        const defaultOptions = { mustSetFocus: true, mustToggle: true };\n        const selectOptions = { ...defaultOptions, ...(optionsParam || {}) };\n\n        const canSelect = (): boolean => {\n            if (this.options.onCanSelectNode) {\n                return (\n                    this.options.selectable === true &&\n                    this.options.onCanSelectNode(node)\n                );\n            } else {\n                return this.options.selectable === true;\n            }\n        };\n\n        const openParents = (): void => {\n            const parent = node.parent;\n\n            if (parent && parent.parent && !parent.is_open) {\n                this.openNode(parent, false);\n            }\n        };\n\n        if (!canSelect()) {\n            return;\n        }\n\n        if (this.selectNodeHandler.isNodeSelected(node)) {\n            if (selectOptions.mustToggle) {\n                this.deselectCurrentNode();\n                this._triggerEvent(\"tree.select\", {\n                    node: null,\n                    previous_node: node,\n                });\n            }\n        } else {\n            const deselectedNode = this.getSelectedNode() || null;\n            this.deselectCurrentNode();\n            this.addToSelection(node, selectOptions.mustSetFocus);\n\n            this._triggerEvent(\"tree.select\", {\n                node,\n                deselected_node: deselectedNode,\n            });\n            openParents();\n        }\n\n        saveState();\n    }\n\n    private doLoadData(data: NodeData[] | null, parentNode: Node | null): void {\n        if (!data) {\n            return;\n        } else {\n            this._triggerEvent(\"tree.load_data\", { tree_data: data });\n\n            if (parentNode) {\n                this.deselectNodes(parentNode);\n                this.loadSubtree(data, parentNode);\n            } else {\n                this.initTree(data);\n            }\n\n            if (this.isDragging()) {\n                this.dndHandler.refresh();\n            }\n        }\n    }\n\n    private deselectNodes(parentNode: Node): void {\n        const selectedNodesUnderParent = this.selectNodeHandler.getSelectedNodesUnder(\n            parentNode\n        );\n        for (const n of selectedNodesUnderParent) {\n            this.selectNodeHandler.removeFromSelection(n);\n        }\n    }\n\n    private loadSubtree(data: any[], parentNode: Node): void {\n        parentNode.loadFromData(data);\n\n        parentNode.load_on_demand = false;\n        parentNode.is_loading = false;\n\n        this._refreshElements(parentNode);\n    }\n\n    private doLoadDataFromUrl(\n        urlInfoParam: string | JQuery.AjaxSettings | null,\n        parentNode: Node | null,\n        onFinished: HandleFinishedLoading | null\n    ): void {\n        const urlInfo = urlInfoParam || this.getDataUrlInfo(parentNode);\n\n        this.dataLoader.loadFromUrl(urlInfo, parentNode, onFinished);\n    }\n\n    private loadFolderOnDemand(\n        node: Node,\n        slide = true,\n        onFinished: OnFinishOpenNode | null\n    ): void {\n        node.is_loading = true;\n\n        this.doLoadDataFromUrl(null, node, () => {\n            this._openNode(node, slide, onFinished);\n        });\n    }\n}\n\nSimpleWidget.register(JqTreeWidget, \"tree\");\n","const version = \"1.5.2\";\n\nexport default version;\n"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","__extends","__","this","constructor","create","Position","__assign","assign","t","s","i","n","arguments","length","apply","positionNames","before","Before","after","After","inside","Inside","none","None","getPositionName","position","name_1","o","isRoot","nodeClass","name","isEmptyFolder","load_on_demand","setData","children","parent","idMapping","tree","Node","key","value","data","removeChildren","data_1","_i","node","createNode","addChild","loadFromData","push","setParent","index","splice","doRemoveChild","indexOf","hasChildren","callback","_iterate","level","_a","child","movedNode","targetNode","isParentOf","addChildAtPosition","getChildIndex","includeParent","getDataFromNodes","nodes","map","tmpNode","k","v","getNodeByCallback","result","iterate","nodeInfo","childIndex","newParent","originalParent","removeChild","nodeId","id","_this","removeNodeFromIndex","previousIndex","nextIndex","filter","f","includeChildren","is_open","nextSibling","getNextSibling","getNextNode","previousSibling","getPreviousSibling","getLastChild","getParent","lastChild","nodeData","addChildren","childrenData","childrenData_1","initFromData","addNodeToIndex","getNodeClass","jQuery","jQueryProxy[\"default\"]","jQueryProxy","treeWidget","hoveredArea","hitAreas","isDragging","currentItem","positionInfo","DragAndDropHandler","$element","target","mustCaptureElement","options","onIsMoveHandle","nodeElement","_getNodeElement","onCanMove","undefined","pageX","pageY","refresh","offset","left","top","dragElement","DragElement","element","autoEscape","addClass","move","area","findHoveredArea","canMoveToArea","isFolder","stopOpenFolderTimer","mustOpenFolderTimer","startOpenFolderTimer","updateDropHint","removeDropHint","onDragMove","originalEvent","moveItem","clear","removeHover","removeHitAreas","removeClass","onDragStop","generateHitAreas","_getNodeElementForNode","hitAreasGenerator","HitAreasGenerator","getTreeDimensions","bottom","generate","is","onCanMoveTo","positionName","remove","previousGhost","x","y","dimensions","right","low","high","mid","addDropHint","folder","openFolderTimer","window","setTimeout","_openNode","slide","openFolderDelay","clearTimeout","movedNode_1","targetNode_1","position_1","previousParent","doMove","moveNode","empty","_refreshElements","_triggerEvent","move_info","moved_node","target_node","previous_parent","do_move","original_event","isDefaultPrevented","el","width","height","_getScrollLeft","currentNode","treeBottom","_super","positions","lastTop","previousTop","group","positions_1","generateHitAreasForGroup","addPosition","getTop","nextNode","positionsInGroup","positionCount","Math","min","areaHeight","round","areaTop","VisibleNodeIterator","isFirstNode","_iterateNode","mustIterateInside","handleFirstNode","handleOpenFolder","handleClosedFolder","handleNode","childrenLength_1","forEach","_","handleAfterOpenFolder","nodeName","offsetX","offsetY","$tree","text","html","css","append","getBoolString","openedIconElement","createButtonElement","openedIcon","closedIconElement","closedIcon","ElementsRenderer","fromNode","renderFromNode","renderFromRoot","createDomElements","$previousLi","li","createLi","getLevel","attachNodeData","isRootNode","ul","createUl","appendChild","children_1","classString","role","rtl","dragAndDrop","document","createElement","className","setAttribute","isSelected","Boolean","selectNodeHandler","isNodeSelected","showEmptyFolder","createFolderLi","createNodeLi","onCreateLi","buttonClasses","getButtonClasses","folderClasses","getFolderClasses","iconElement","div","buttonLink","cloneNode","buttonLeft","createTitleSpan","liClasses","join","isOpen","titleSpan","classes","tabIndex","textContent","innerHTML","is_loading","createTextNode","DataLoader","urlInfo","parentNode","onFinished","$el","getDomElement","addLoadingClass","notifyLoading","stopLoading","removeLoadingClass","submitRequest","loadData","parseData","jqXHR","onLoadFailed","isLoading","onLoading","urlInfoInput","handleSuccess","handleError","ajaxSettings","method","cache","dataType","success","error","url","toUpperCase","ajax","dataFilter","parsedData","JSON","parse","e","canHandleKeyboard","selectedNode","getSelectedNode","which","KeyHandler","DOWN","moveDown","UP","moveUp","RIGHT","moveRight","LEFT","moveLeft","keyboardSupport","on","handleKeyDown","off","selectNode","getPreviousNode","openNode","closeNode","scrollHandler","isScrolledIntoView","find","scrollToNode","isFocusOnTree","register","widgetClass","widgetName","getDataKey","getWidgetData","dataKey","widget","SimpleWidget","createWidget","get","init","destroyWidget","destroy","removeData","callFunction","functionName","args","widgetFunction","fn","argument1","defaults","deinit","getPositionInfoFromMouseEvent","getPositionInfoFromTouch","touch","button","handleMouseDown","cancelable","preventDefault","handleMouseMove","handleMouseUp","touches","changedTouches","MouseWidget","addEventListener","mouseDown","passive","touchStart","isMouseStarted","mouseDelayTimer","isMouseDelayMet","mouseDownInfo","removeEventListener","mouseMove","touchMove","mouseUp","touchEnd","mouseCapture","handleStartMouse","mouseDelay","getMouseDelay","startMouseDelayTimer","mouseDrag","mouseStart","mouseStop","SaveStateHandler","state","stringify","getState","onSetStateFromStorage","supportsLocalStorage","localStorage","setItem","getKeyName","jsonData","loadFromStorage","parseState","selectedNodeIds","openNodes","open_nodes","selected_node","getSelectedNodes","mustLoadOnDemand","openInitialNodes","resetSelection","selectInitialNodes","cbFinished","doSetInitialStateOnDemand","getStateFromStorage","onGetStateFromStorage","getItem","nodeIds","nodeIds_1","nodeDd","getNodeById","selectCount","nodeIds_2","addToSelection","removeFromSelection","nodeIdsParam","selectedNodes","loadingCount","newNodesIds","nodeIds_3","loadAndOpenNode","saveState","_supportsLocalStorage","sessionStorage","removeItem","testSupport","isInitialized","ScrollHandler","ensureInit","checkVerticalScrolling","checkHorizontalScrolling","$scrollParent","scrollTop","treeTop","elementBottom","viewBottom","elementTop","viewTop","elHeight","scrollParentTop","scrollLeft","setDocumentAsScrollParent","cssAttributes","hasOverFlow","cssAttributes_1","attr","overflowValue","parents","getParentWithOverflow","tagName","initScrollParent","scrollParent","offsetHeight","refreshHitAreas","dndHandler","handleVerticalScrollingWithScrollParent","handleVerticalScrollingWithDocument","handleHorizontalScrollingWithParent","handleHorizontalScrollingWithDocument","scrollParentOffset","canScrollRight","clientWidth","scrollWidth","canScrollLeft","rightEdge","leftEdge","isNearRightEdge","isNearLeftEdge","max","$document","windowWidth","SelectNodeHandler","selectedSingleNode","activeElement","_containsElement","NodeElement","mustShowBorderDropHint","BorderDropHint","GhostDropHint","mustSetFocus","$li","getLi","$span","getSpan","trigger","removeAttr","blur","FolderElement","animationSpeed","$button","getButton","buttonEl","icon","renderer","doOpen","getUl","slideDown","show","doClose","slideUp","hide","$div","elWidth","outerHeight","$hint","$ghost","moveAfter","moveBefore","moveInsideOpenFolder","moveInside","NODE_PARAM_IS_EMPTY","PARAM_IS_EMPTY","clickTarget","getClickTarget","type","toggle","stopPropagation","click_event","doSelectNode","closest","getNode","JqTreeWidget","slideParam","Error","optionsParam","getData","doLoadData","param1","param2","param3","doLoadDataFromUrl","getNodeByName","getNodeByNameMustExist","getNodesByProperty","parseParams","close","newNodeInfo","existingNode","newNode","addAfter","addBefore","addParent","parentNodeParam","prepend","idIsChanged","mustSelect","isSelectedNodeInSubtree","selectCurrentNode","subtree","positionIndex","saveStateHandler","select","deselect","nodeOffset","nodeTop","treeOffset","scrollToY","setInitialState","option","keyHandler","eventName","values","event","Event","doOpenNode","_node","_slide","_onFinished","open","loadFolderOnDemand","parent_1","render","getScrollLeft","getRtlOption","getDefaultClosedIcon","dataLoader","initData","handleClick","handleDblclick","useContextMenu","handleContextmenu","checkScrolling","startDndDelay","getDataUrlInfo","dataUrl","setUrlInfoData","selectedNodeId","getNodeIdToBeSelected","doInit","setInitialStateOnDemand","restoreState","isRestored","autoOpen","maxLevel","getAutoOpenMaxLevel","autoOpenNodes","parseInt","$target","dataRtl","deselectCurrentNode","selectOptions","mustToggle","onCanSelectNode","selectable","previous_node","deselectedNode","deselected_node","tree_data","deselectNodes","loadSubtree","initTree","selectedNodesUnderParent_1","getSelectedNodesUnder","urlInfoParam","loadFromUrl"],"mappings":"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"}